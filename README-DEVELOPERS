
 There are four main ways you, as a developer, can use this library:

1. Have a dependancy, #include <ustr.h> and link with -lustr

2. Use pkg-config normally, like: $(pkg-config --cflags --libs ustr)

3. Run ustr-import -c all, once, and then add the ustr*.c files to
your build system and #include "ustr.h"

4. Run ustr-import all, once, and then just #include "ustr.h"


 --------------------------------------------
 If you want to add something to this library
 --------------------------------------------

 Probably the first thing to do is:

 git clone http://www.and.org/ustr/ustr.git

...then you unless what you're doing obviously fits into one of the
existing files create a new namespace, lets say ustr-foo, to do that
create the files:

ustr-foo.h
ustr-foo-code.h
ustr-foo-dbg-code.c
ustr-foo-opt-code.c

...and possibly, if you want another ustr-* namespace to be able to
access your internal functions:

ustr-foo-internal.h

...the easiest way to make them is to copy the top and bottom from say
ustr-srch* and change the names to protect the innocent :). 

 When creating functions there are six pre-defined constants you
should use:

USTR_CONF_E_PROTO
	 This is the one for the extern definition
USTR_CONF_I_PROTO
	 This is the one for the implementation
USTR_CONF_EI_PROTO
	 This is the one for the extern definition, when you want
	inline'ing in the library.
USTR_CONF_II_PROTO
	 This is the one for the implementation, when you want
	inline'ing in the library.

USTR_CONF_e_PROTO
	This is the one for the extern definition, for internal symbols.
USTR_CONF_i_PROTO
	This is the one for the implementation, for internal symbols.


 When creating functions they are usually done in a set, so for every
one task you want to do you create about five or six functions:

  ustr_add;
  ustr_add_buf;
  ustr_add_cstr;
  ustr_add_rep_chr;
  ustr_add_subustr;
  ustr_add_undef;

 A quick reference would be:

 *_undef()   == malloc() / realloc().
 *_buf()     == *_undef() + memcpy()
 *_rep_chr() == *_undef() + memset()
 *_cstr()    == strlen() + *_buf()
 *()         == small optimizations or ustr_len() + *_buf().
 *_subustr() == Like *() but with limits in the data.

...the current documentation also has them documented, to some extent.
 Next you'll want to alter the Makefile, again the easiest thing to do
is search for something similar like "ustr_srch" and add your file to
each variable.
 You should also do the same for examples/Makefile, if any of the
examples will use the new functions.

 You then want to add your namespace to the end of the file lists in:

scripts/list_functions_src.pl
scripts/gen_doc_templ_from_protos.pl

...after which you can run:

./scripts/cmp_symbols_ver.sh

...to see what symbols you need to add to the linker map file, and:

./scripts/cmp_symbols_doc.sh

...to see which functions aren't documented. You can add unit tests as
T/*.c, the ones begining with ctst_*.c are linked against a local
library and T/tst_*.c use just the header files (and the C source for
them is generated by appending the ctst_*.c file of the same name).

 After all that you can run:

./scripts/coverage.sh

...which will generate a testing coverage report, using lcov, in the
directory ./lcov-output/lib
