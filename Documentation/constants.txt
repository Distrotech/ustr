Section: Compile switch constants

Constant: USTR_CONF_INCLUDE_CODEONLY_HEADERS

 Explanation:

  This switch controls whether all the code will be included as inline
 functions. Having this be non-zero means that you don't have to link against
 the library.


Constant: USTR_CONF_USE_EOS_MARK

 Explanation:

  This switch turns on End of String markers, so any bounds overflow will be
 noticed by ustr_assert_valid().

 Note:

  Changing this will not do anything useful unless
 USTR_CONF_INCLUDE_CODEONLY_HEADERS is non-zero.


Constant: USTR_CONF_USE_ASSERT

 Explanation:

  This switch turns USTR_ASSERT() calls on, so the code within them will be
 evaluated. Note that there are many calls to ustr_assert_valid() within
 USTR_ASSERT() macros and that call is relatively expensive.

 Note:

  Changing this will not do anything useful unless
 USTR_CONF_INCLUDE_CODEONLY_HEADERS is non-zero.


Constant: USTR_CONF_COMPILE_USE_ATTRIBUTES

 Explanation:

  This switch controls whether gcc type __attribute__() statements are used in
 the public headers headers for the library. If the value is 1 then if they are
 supported by the compiler that built the library they will be used, if the
 value is 0 they won't be used at all.


Constant: USTR_CONF_COMPILE_TYPEDEF

 Explanation:

  This switch controls whether typedef will be used for the structs in the
 public headers for the library. If the value is 1 then they will be used,
 if the value is 0 they won't be used at all (and your code will have to use
 struct tags instead -- note all libraries using ustr should compile without
 this option set).

Constant: USTR_CONF_COMPILE_USE_INLINE

 Explanation:

  This switch controls whether inline functions will be used in a few cases
 where the function bodies are very small.

 Note:

  In some cases this is used so that GCC can eliminate calls to strlen(), for
 the *_cstr() functions.


Section: Constants to created fixed/read-only Ustr's
Constant: USTR_BEG_CONST1

 Explanation:

  This macro is a constant C-style string of the first byte of a
 constant/read-only Ustr that has a length in the range 0-255.


Constant: USTR_BEG_CONST2

 Explanation:

  This macro is a constant C-style string of the first byte of a
 constant/read-only Ustr that has a length in the range 0-65535.


Constant: USTR_BEG_CONST4

 Explanation:

  This macro is a constant C-style string of the first byte of a
 constant/read-only Ustr that has a length in the range 0-4294967295.


Constant: USTR_BEG_FIXED1

 Explanation:

  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-255.


Constant: USTR_BEG_FIXED2

 Explanation:

  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-65535.


Constant: USTR_BEG_FIXED4

 Explanation:

  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-4294967295.


Constant: USTR_BEG_FIXED8

 Explanation:

  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-18446744073709551615.

 Note:

  This macro is only available if the Ustr code was compiled in a 64bit
 environment.


Constant: USTR_END_ALOCDx

 Explanation:

  This macro is a constant C-style string of the last bytes of an
 allocated Ustr.

 Note:

  Unless USTR_CONF_USE_EOS_MARK is non-zero, this is just the NIL byte.


Constant: USTR_END_CONSTx

 Explanation:

  This macro is a constant C-style string of the last bytes of a
 constant/read-only Ustr.

 Note:

  Unless USTR_CONF_USE_EOS_MARK is non-zero, this is just the NIL byte.


Constant: USTR_END_FIXEDx

 Explanation:

  This macro is a constant C-style string of the last bytes of a
 fixed Ustr.

 Note:

  Unless USTR_CONF_USE_EOS_MARK is non-zero, this is just the NIL byte.


Section: Constants to pass to ustr_split*
Constant: USTR_FLAG_SPLIT_DEF

 Explanation:

  Default flags, this is merely 0 but can be used a program documentation.


Constant: USTR_FLAG_SPLIT_RET_SEP

 Explanation:

  Return the separator along with the tokens. For example splitting "a,b,"
 using separator "," will return the tokens "a," and "b," whereas without this
 flag only "a" and "b" would be returned.
    
Constant: USTR_FLAG_SPLIT_RET_NON

 Explanation:

  Return empty tokens. For example: splitting "a,,b" with separator "," will
 return the tokens {"a" "" "b"}.

Constant: USTR_FLAG_SPLIT_KEEP_CONFIG

 Explanation:

  Force the returned Ustr's to have same configuration parameters as the
 Ustr string that is being split.


Section: Misc constants to use in code
Constant: USTR_NULL

 Explanation:

  This macro is merely 0 cast to (struct Ustr *), and can be used anywhere NULL
 would be but "returns" the correct type.


Constant: USTR_POOL_NULL

 Explanation:

  This macro is merely 0 cast to (struct Ustr_pool *), and can be used anywhere
 NULL would be but "returns" the correct type.


Constant: USTR_TRUE

 Explanation:

  This macro is 1, but shows the intent that a boolean value is expected and not
 a number.


Constant: USTR_FALSE

 Explanation:

  This macro is 0, but shows the intent that a boolean value is expected and not
 a number.


Section: Constants passed to ustr_cntl_opt()
Constant: USTR_CNTL_OPT_GET_REF_BYTES

 Parameter[1]: Number of bytes for default reference count in Ustr
 Type[1]: size_t *

 Explanation:

  This option will get the default number of bytes used for a reference count
 when creating Ustr's.


Constant: USTR_CNTL_OPT_SET_REF_BYTES

 Parameter[1]: Number of bytes for default reference count in Ustr
 Type[1]: size_t

 Explanation:

  This option will set the default number of bytes used for a reference count
 when creating Ustr's.

 Note:

  For a single instance, the ustr_dupx_*() functions can be used.


Constant: USTR_CNTL_OPT_GET_HAS_SIZE

 Parameter[1]: Default flag for whether to include an explicit size in a Ustr
 Type[1]: size_t *

 Explanation:

  This option will get the default flag for whether to store an explicit size
 in created Ustr's.


Constant: USTR_CNTL_OPT_SET_HAS_SIZE

 Parameter[1]: Default flag for whether to include an explicit size in a Ustr
 Type[1]: size_t

 Explanation:

  This option will set the default flag for whether to store an explicit size
 in created Ustr's.

 Note:

  For a single instance, the ustr_dupx_*() functions can be used.


Constant: USTR_CNTL_OPT_GET_EXACT_BYTES

 Parameter[1]: Default flag for whether to exactly allocate memory
 Type[1]: size_t *

 Explanation:

  This option will get the default flag for whether to exactly allocate memory
 when a Ustr needs to be resized.


Constant: USTR_CNTL_OPT_SET_EXACT_BYTES

 Parameter[1]: Default flag for whether to exactly allocate memory
 Type[1]: size_t

 Explanation:

  This option will set the default flag for whether to exactly allocate memory
 when a Ustr needs to be resized.

 Note:

  For a single instance, the ustr_dupx_*() functions can be used.


Constant: USTR_CNTL_OPT_GET_MEM
 Parameter[1]: Pointer to colleciton of function pointers for system allocation
 Type[1]: struct Ustr_cntl_mem *

 Explanation:

  This option will get the "system" allocation functions (malloc, realloc, free)
 for allocated Ustr's.


Constant: USTR_CNTL_OPT_GET_MEM
 Parameter[1]: Pointer to colleciton of function pointers for system allocation
 Type[1]: const struct Ustr_cntl_mem *

 Explanation:

  This option will set the "system" allocation functions (malloc, realloc, free)
 for allocated Ustr's.

 Note:

  As you would expect the default values are: malloc, realloc, free.
  If this option is set after a Ustr has been created, then when freeing or
 reallocating the existing Ustr the given functions will be used. So they must
 either be compatible with the default or you must ensure that nothing is
 allocated before they are set.
