.TH ustr 3 "26-Jul-2007" "Ustr 1.0.1" "Ustr String Library"
.SH "SYNOPSIS"
.in \w'  'u
#include "ustr.h"
.sp
.NH
.sp
.br
.in \w'  struct Ustr *\fBUSTR\fR('u
.ti \w'  'u
struct Ustr *\fBUSTR\fR(void *);
.br
.in \w'  struct Ustrp *\fBUSTRP\fR('u
.ti \w'  'u
struct Ustrp *\fBUSTRP\fR(void *);
.br
.in \w'  struct Ustr *\fBUSTR1\fR('u
.ti \w'  'u
struct Ustr *\fBUSTR1\fR(symbol, const char[]);
.br
.in \w'  struct Ustr *\fBUSTR2\fR('u
.ti \w'  'u
struct Ustr *\fBUSTR2\fR(symbol, symbol, const char[]);
.br
.in \w'  struct Ustr *\fBUSTR4\fR('u
.ti \w'  'u
struct Ustr *\fBUSTR4\fR(symbol, symbol, symbol, symbol, const char[]);
.br
.in \w'  struct Ustr *\fBUSTRP1\fR('u
.ti \w'  'u
struct Ustr *\fBUSTRP1\fR(symbol, const char[]);
.br
.in \w'  struct Ustr *\fBUSTRP2\fR('u
.ti \w'  'u
struct Ustr *\fBUSTRP2\fR(symbol, symbol, const char[]);
.br
.in \w'  struct Ustrp *\fBUSTRP4\fR('u
.ti \w'  'u
struct Ustrp *\fBUSTRP4\fR(symbol, symbol, symbol, symbol, const char[]);
.sp
.br
.in \w'  size_t \fBUSTR_SIZE_FIXED\fR('u
.ti \w'  'u
size_t \fBUSTR_SIZE_FIXED\fR(size_t);
.br
.in \w'  struct Ustr *\fBustr_init_fixed\fR('u
.ti \w'  'u
struct Ustr *\fBustr_init_fixed\fR(void *, size_t, int, size_t);
.br
.in \w'  struct Ustr *\fBUSTR_SC_INIT_AUTO\fR('u
.ti \w'  'u
struct Ustr *\fBUSTR_SC_INIT_AUTO\fR(char[], int, size_t);
.sp
.br
.in \w'  struct Ustr *\fBustr_init_alloc\fR('u
.ti \w'  'u
struct Ustr *\fBustr_init_alloc\fR(void *, size_t, size_t, size_t, int, int, size_t);
.br
.in \w'  struct Ustr *\fBustr_dupx_empty\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dupx_empty\fR(size_t, size_t, int, int);
.br
.in \w'  struct Ustr *\fBustr_dup_empty\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dup_empty\fR(void);
.br
.in \w'  struct Ustr *\fBustr_dupx_undef\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dupx_undef\fR(size_t, size_t, int, int, size_t);
.br
.in \w'  struct Ustr *\fBustr_dup_undef\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dup_undef\fR(size_t);
.br
.in \w'  struct Ustr *\fBustr_dup\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dup\fR(const struct Ustr *);
.br
.in \w'  struct Ustr *\fBustr_dupx\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dupx\fR(size_t, size_t, int, int, const struct Ustr *);
.br
.in \w'  struct Ustr *\fBustr_sc_dupx\fR('u
.ti \w'  'u
struct Ustr *\fBustr_sc_dupx\fR(size_t, size_t, int, int, struct Ustr **);
.br
.in \w'  struct Ustr *\fBustr_sc_dup\fR('u
.ti \w'  'u
struct Ustr *\fBustr_sc_dup\fR(struct Ustr **);
.sp
.br
.in \w'  void  \fBustr_free\fR('u
.ti \w'  'u
void  \fBustr_free\fR(struct Ustr *);
.br
.in \w'  void  \fBustrp_free\fR('u
.ti \w'  'u
void  \fBustrp_free\fR(struct Ustr_pool *, struct Ustrp *);
.br
.in \w'  void  \fBustr_sc_free\fR('u
.ti \w'  'u
void  \fBustr_sc_free\fR(struct Ustr **);
.br
.in \w'  void  \fBustr_sc_free2\fR('u
.ti \w'  'u
void  \fBustr_sc_free2\fR(struct Ustr **, struct Ustr *);
.br
.in \w'  void  \fBustr_sc_free_shared\fR('u
.ti \w'  'u
void  \fBustr_sc_free_shared\fR(struct Ustr **);
.br
.in \w'  int  \fBustr_del\fR('u
.ti \w'  'u
int  \fBustr_del\fR(struct Ustr **, size_t);
.br
.in \w'  int  \fBustr_del_subustr\fR('u
.ti \w'  'u
int  \fBustr_del_subustr\fR(struct Ustr **, size_t,  size_t);
.br
.in \w'  void  \fBustr_sc_del\fR('u
.ti \w'  'u
void  \fBustr_sc_del\fR(struct Ustr **);
.sp
.br
.in \w'  int \fBustr_add_undef\fR('u
.ti \w'  'u
int \fBustr_add_undef\fR(struct Ustr **, size_t);
.br
.in \w'  int \fBustr_add_buf\fR('u
.ti \w'  'u
int \fBustr_add_buf\fR(struct Ustr **, const void *, size_t);
.br
.in \w'  int  \fBustr_add_cstr\fR('u
.ti \w'  'u
int  \fBustr_add_cstr\fR(struct Ustr **, const char *);
.br
.in \w'  int  \fBustr_add\fR('u
.ti \w'  'u
int  \fBustr_add\fR(struct Ustr **, const struct Ustr *);
.br
.in \w'  int  \fBustr_add_subustr\fR('u
.ti \w'  'u
int  \fBustr_add_subustr\fR(struct Ustr **, const struct Ustr *, size_t, size_t);
.br
.in \w'  int  \fBustr_add_rep_chr\fR('u
.ti \w'  'u
int  \fBustr_add_rep_chr\fR(struct Ustr **, char, size_t);
.sp
.br
.in \w'  int  \fBustr_set_undef\fR('u
.ti \w'  'u
int  \fBustr_set_undef\fR(struct Ustr **,  size_t);
.br
.in \w'  int \fBustr_set_empty\fR('u
.ti \w'  'u
int \fBustr_set_empty\fR(struct Ustr **);
.br
.in \w'  int \fBustr_set_buf\fR('u
.ti \w'  'u
int \fBustr_set_buf\fR(struct Ustr **,  const void *,  size_t);
.br
.in \w'  int \fBustr_set_cstr\fR('u
.ti \w'  'u
int \fBustr_set_cstr\fR(struct Ustr **,  const char *);
.br
.in \w'  int \fBustr_set\fR('u
.ti \w'  'u
int \fBustr_set\fR(struct Ustr **, const struct Ustr *);
.br
.in \w'  int \fBustr_set_subustr\fR('u
.ti \w'  'u
int \fBustr_set_subustr\fR(struct Ustr **, const struct Ustr *, size_t, size_t);
.br
.in \w'  int \fBustr_set_rep_chr\fR('u
.ti \w'  'u
int \fBustr_set_rep_chr\fR(struct Ustr **, char, size_t);
.sp
.br
.in \w'  int \fBustr_realloc\fR('u
.ti \w'  'u
int \fBustr_realloc\fR(struct Ustr **, size_t);
.sp
.br
.in \w'  int  \fBustr_add_vfmt_lim\fR('u
.ti \w'  'u
int  \fBustr_add_vfmt_lim\fR(struct Ustr **, size_t, const char *, va_list);
.br
.in \w'  int  \fBustr_add_vfmt\fR('u
.ti \w'  'u
int  \fBustr_add_vfmt\fR(struct Ustr **, const char *, va_list);
.br
.in \w'  int  \fBustr_add_fmt\fR('u
.ti \w'  'u
int  \fBustr_add_fmt\fR(struct Ustr **, const char *, ...);
.br
.in \w'  int  \fBustr_add_fmt_lim\fR('u
.ti \w'  'u
int  \fBustr_add_fmt_lim\fR(struct Ustr **, size_t, const char *, ...);
.br
.in \w'  struct Ustr *\fBustr_dupx_fmt_lim\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dupx_fmt_lim\fR(size_t, size_t, int, int, size_t, const char *, ...);
.br
.in \w'  struct Ustr *\fBustr_dup_fmt_lim\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dup_fmt_lim\fR(size_t, const char *, ...);
.br
.in \w'  struct Ustr *\fBustr_dupx_fmt\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dupx_fmt\fR(size_t, size_t, int, int, const char *, ...);
.br
.in \w'  struct Ustr *\fBustr_dup_fmt\fR('u
.ti \w'  'u
struct Ustr *\fBustr_dup_fmt\fR(const char *, ...);
.br
.in \w'  int  \fBustr_set_vfmt_lim\fR('u
.ti \w'  'u
int  \fBustr_set_vfmt_lim\fR(struct Ustr **, size_t, const char *, va_list);
.br
.in \w'  int  \fBustr_set_vfmt\fR('u
.ti \w'  'u
int  \fBustr_set_vfmt\fR(struct Ustr **, const char *, va_list);
.br
.in \w'  int  \fBustr_set_fmt_lim\fR('u
.ti \w'  'u
int  \fBustr_set_fmt_lim\fR(struct Ustr **, size_t, const char *, ...);
.br
.in \w'  int  \fBustr_set_fmt\fR('u
.ti \w'  'u
int  \fBustr_set_fmt\fR(struct Ustr **, const char *, ...);
.sp
.br
.in \w'  size_t  \fBustr_len\fR('u
.ti \w'  'u
size_t  \fBustr_len\fR(const struct Ustr *);
.br
.in \w'  const char *\fBustr_cstr\fR('u
.ti \w'  'u
const char *\fBustr_cstr\fR(const struct Ustr *);
.br
.in \w'  char *\fBustr_wstr\fR('u
.ti \w'  'u
char *\fBustr_wstr\fR(struct Ustr *);
.br
.in \w'  int \fBustr_alloc\fR('u
.ti \w'  'u
int \fBustr_alloc\fR(const struct Ustr *);
.br
.in \w'  int \fBustr_exact\fR('u
.ti \w'  'u
int \fBustr_exact\fR(const struct Ustr *);
.br
.in \w'  int  \fBustr_sized\fR('u
.ti \w'  'u
int  \fBustr_sized\fR(const struct Ustr *);
.br
.in \w'  int \fBustr_ro\fR('u
.ti \w'  'u
int \fBustr_ro\fR(const struct Ustr *);
.br
.in \w'  int  \fBustr_fixed\fR('u
.ti \w'  'u
int  \fBustr_fixed\fR(const struct Ustr *);
.br
.in \w'  int  \fBustr_enomem\fR('u
.ti \w'  'u
int  \fBustr_enomem\fR(const struct Ustr *);
.br
.in \w'  int  \fBustr_shared\fR('u
.ti \w'  'u
int  \fBustr_shared\fR(const struct Ustr *);
.br
.in \w'  int  \fBustr_limited\fR('u
.ti \w'  'u
int  \fBustr_limited\fR(const struct Ustr *);
.br
.in \w'  int  \fBustr_owner\fR('u
.ti \w'  'u
int  \fBustr_owner\fR(const struct Ustr *);
.br
.in \w'  size_t  \fBustr_size\fR('u
.ti \w'  'u
size_t  \fBustr_size\fR(const struct Ustr *);
.br
.in \w'  size_t  \fBustr_size_alloc\fR('u
.ti \w'  'u
size_t  \fBustr_size_alloc\fR(const struct Ustr *);
.br
.in \w'  size_t  \fBustr_size_overhead\fR('u
.ti \w'  'u
size_t  \fBustr_size_overhead\fR(const struct Ustr *);
.sp
.br
.in \w'  int  \fBustr_setf_enomem_err\fR('u
.ti \w'  'u
int  \fBustr_setf_enomem_err\fR(struct Ustr *);
.br
.in \w'  int  \fBustr_setf_enomem_clr\fR('u
.ti \w'  'u
int  \fBustr_setf_enomem_clr\fR(struct Ustr *);
.br
.in \w'  int  \fBustr_setf_share\fR('u
.ti \w'  'u
int  \fBustr_setf_share\fR(struct Ustr *);
.br
.in \w'  int  \fBustr_setf_owner\fR('u
.ti \w'  'u
int  \fBustr_setf_owner\fR(struct Ustr *);
.sp
.br
.in \w'  int  \fBustr_cmp_buf\fR('u
.ti \w'  'u
int  \fBustr_cmp_buf\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp\fR('u
.ti \w'  'u
int  \fBustr_cmp\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_subustr\fR('u
.ti \w'  'u
int  \fBustr_cmp_subustr\fR(const struct Ustr *, const struct Ustr *, size_t, size_t);
.br
.in \w'  int  \fBustr_cmp_cstr\fR('u
.ti \w'  'u
int  \fBustr_cmp_cstr\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_fast_buf\fR('u
.ti \w'  'u
int  \fBustr_cmp_fast_buf\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_fast\fR('u
.ti \w'  'u
int  \fBustr_cmp_fast\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_fast_subustr\fR('u
.ti \w'  'u
int  \fBustr_cmp_fast_subustr\fR(const struct Ustr *, const struct Ustr *, size_t, size_t);
.br
.in \w'  int  \fBustr_cmp_fast_cstr\fR('u
.ti \w'  'u
int  \fBustr_cmp_fast_cstr\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_case_buf\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_buf\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_case\fR('u
.ti \w'  'u
int  \fBustr_cmp_case\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_case_subustr\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_subustr\fR(const struct Ustr *, const struct Ustr *, size_t, size_t);
.br
.in \w'  int  \fBustr_cmp_case_cstr\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_cstr\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_eq\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_buf_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_buf_eq\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_subustr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_subustr_eq\fR(const struct Ustr *, const struct Ustr *, size_t, size_t);
.br
.in \w'  int  \fBustr_cmp_cstr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_cstr_eq\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_case_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_eq\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_case_buf_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_buf_eq\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_case_subustr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_subustr_eq\fR(const struct Ustr *, const struct Ustr *, size_t, size_t);
.br
.in \w'  int  \fBustr_cmp_case_cstr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_cstr_eq\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_prefix_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_prefix_eq\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_prefix_buf_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_prefix_buf_eq\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_prefix_cstr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_prefix_cstr_eq\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_case_prefix_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_prefix_eq\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_case_prefix_buf_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_prefix_buf_eq\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_case_prefix_cstr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_prefix_cstr_eq\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_suffix_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_suffix_eq\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_suffix_buf_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_suffix_buf_eq\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_suffix_cstr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_suffix_cstr_eq\fR(const struct Ustr *, const char *);
.br
.in \w'  int  \fBustr_cmp_case_suffix_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_suffix_eq\fR(const struct Ustr *, const struct Ustr *);
.br
.in \w'  int  \fBustr_cmp_case_suffix_buf_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_suffix_buf_eq\fR(const struct Ustr *, const void *, size_t);
.br
.in \w'  int  \fBustr_cmp_case_suffix_cstr_eq\fR('u
.ti \w'  'u
int  \fBustr_cmp_case_suffix_cstr_eq\fR(const struct Ustr *, const char *);
.sp
.br
.in \w'  size_t  \fBustr_srch_chr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_srch_chr_fwd\fR(const struct Ustr *, size_t, char);
.br
.in \w'  size_t  \fBustr_srch_chr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_srch_chr_rev\fR(const struct Ustr *,  size_t, char);
.br
.in \w'  size_t  \fBustr_srch_buf_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_srch_buf_fwd\fR(const struct Ustr *, size_t, const void *, size_t);
.br
.in \w'  size_t  \fBustr_srch_buf_rev\fR('u
.ti \w'  'u
size_t  \fBustr_srch_buf_rev\fR(const struct Ustr *, size_t, const void *, size_t);
.br
.in \w'  size_t  \fBustr_srch_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_srch_fwd\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_srch_rev\fR('u
.ti \w'  'u
size_t  \fBustr_srch_rev\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_srch_cstr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_srch_cstr_fwd\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_srch_cstr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_srch_cstr_rev\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_srch_subustr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_srch_subustr_fwd\fR(const struct Ustr *, size_t, const struct Ustr *, size_t, size_t);
.br
.in \w'  size_t  \fBustr_srch_subustr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_srch_subustr_rev\fR(const struct Ustr *,  size_t, const struct Ustr *, size_t, size_t);
.sp
.br
.in \w'  size_t  \fBustr_spn_chr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_spn_chr_fwd\fR(const struct Ustr *, size_t, char);
.br
.in \w'  size_t  \fBustr_spn_chr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_spn_chr_rev\fR(const struct Ustr *, size_t, char);
.br
.in \w'  size_t  \fBustr_spn_chrs_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_spn_chrs_fwd\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_spn_chrs_rev\fR('u
.ti \w'  'u
size_t  \fBustr_spn_chrs_rev\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_spn_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_spn_fwd\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_spn_rev\fR('u
.ti \w'  'u
size_t  \fBustr_spn_rev\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_spn_cstr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_spn_cstr_fwd\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_spn_cstr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_spn_cstr_rev\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_cspn_chr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_chr_fwd\fR(const struct Ustr *, size_t, char);
.br
.in \w'  size_t  \fBustr_cspn_chr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_chr_rev\fR(const struct Ustr *, size_t, char);
.br
.in \w'  size_t  \fBustr_cspn_chrs_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_chrs_fwd\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_cspn_chrs_rev\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_chrs_rev\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_cspn_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_fwd\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_cspn_rev\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_rev\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_cspn_cstr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_cstr_fwd\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_cspn_cstr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_cspn_cstr_rev\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_utf8_spn_chrs_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_spn_chrs_fwd\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_utf8_spn_chrs_rev\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_spn_chrs_rev\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_utf8_spn_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_spn_fwd\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_utf8_spn_rev\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_spn_rev\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_utf8_spn_cstr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_spn_cstr_fwd\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_utf8_spn_cstr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_spn_cstr_rev\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_utf8_cspn_chrs_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_cspn_chrs_fwd\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_utf8_cspn_chrs_rev\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_cspn_chrs_rev\fR(const struct Ustr *, size_t, const char *, size_t);
.br
.in \w'  size_t  \fBustr_utf8_cspn_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_cspn_fwd\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_utf8_cspn_rev\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_cspn_rev\fR(const struct Ustr *, size_t, const struct Ustr *);
.br
.in \w'  size_t  \fBustr_utf8_cspn_cstr_fwd\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_cspn_cstr_fwd\fR(const struct Ustr *, size_t, const char *);
.br
.in \w'  size_t  \fBustr_utf8_cspn_cstr_rev\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_cspn_cstr_rev\fR(const struct Ustr *, size_t, const char *);
.sp
.br
.in \w'  int  \fBustr_io_get\fR('u
.ti \w'  'u
int  \fBustr_io_get\fR(struct Ustr **, FILE *, size_t, size_t *);
.br
.in \w'  int  \fBustr_io_getfile\fR('u
.ti \w'  'u
int  \fBustr_io_getfile\fR(struct Ustr **,  FILE *);
.br
.in \w'  int  \fBustr_io_getfilename\fR('u
.ti \w'  'u
int  \fBustr_io_getfilename\fR(struct Ustr **,  const char *);
.br
.in \w'  int  \fBustr_io_getline\fR('u
.ti \w'  'u
int  \fBustr_io_getline\fR(struct Ustr **,  FILE *);
.br
.in \w'  int  \fBustr_io_put\fR('u
.ti \w'  'u
int  \fBustr_io_put\fR(struct Ustr **,  FILE *,  size_t);
.br
.in \w'  int  \fBustr_io_putline\fR('u
.ti \w'  'u
int  \fBustr_io_putline\fR(struct Ustr **,  FILE *,  size_t);
.br
.in \w'  int  \fBustr_io_putfile\fR('u
.ti \w'  'u
int  \fBustr_io_putfile\fR(struct Ustr **,  FILE *);
.br
.in \w'  int  \fBustr_io_putfileline\fR('u
.ti \w'  'u
int  \fBustr_io_putfileline\fR(struct Ustr **,  FILE *);
.br
.in \w'  int  \fBustr_io_putfilename\fR('u
.ti \w'  'u
int  \fBustr_io_putfilename\fR(struct Ustr **,  const char *,  const char *);
.sp
.br
.in \w'  int  \fBustr_sub_buf\fR('u
.ti \w'  'u
int  \fBustr_sub_buf\fR(struct Ustr **,  size_t,  const void*,  size_t);
.br
.in \w'  int  \fBustr_sub_cstr\fR('u
.ti \w'  'u
int  \fBustr_sub_cstr\fR(struct Ustr **,  size_t,  const char *);
.br
.in \w'  int  \fBustr_sc_sub\fR('u
.ti \w'  'u
int  \fBustr_sc_sub\fR(struct Ustr **, size_t, size_t, const struct Ustr *);
.br
.in \w'  int  \fBustr_sc_sub_buf\fR('u
.ti \w'  'u
int  \fBustr_sc_sub_buf\fR(struct Ustr **,  size_t ,  size_t ,  const void *,  size_t );
.br
.in \w'  int  \fBustr_replace\fR('u
.ti \w'  'u
int  \fBustr_replace\fR(struct Ustr **, const struct Ustr *, const struct Ustr *,  size_t);
.br
.in \w'  size_t \fBustr_replace_rep_chr\fR('u
.ti \w'  'u
size_t \fBustr_replace_rep_chr\fR(struct Ustr **ps1, char, size_t, char, size_t nlen, size_t lim);
.sp
.br
.in \w'  struct Ustr *\fBustr_split_buf\fR('u
.ti \w'  'u
struct Ustr *\fBustr_split_buf\fR(const struct Ustr *, size_t *, const void *, size_t, struct Ustr *, unsigned int);
.br
.in \w'  struct Ustr *\fBustr_split\fR('u
.ti \w'  'u
struct Ustr *\fBustr_split\fR(const struct Ustr *, size_t *, const struct Ustr *, struct Ustr *, unsigned int);
.br
.in \w'  struct Ustr *\fBustr_split_cstr\fR('u
.ti \w'  'u
struct Ustr *\fBustr_split_cstr\fR(const struct Ustr *, size_t *, const char *, struct Ustr *, unsigned int);
.br
.in \w'  struct Ustr *\fBustr_split_spn_chrs\fR('u
.ti \w'  'u
struct Ustr *\fBustr_split_spn_chrs\fR(const struct Ustr *, size_t *, const char *, size_t, struct Ustr *, unsigned int);
.sp
.br
.in \w'  int  \fBustr_utf8_valid\fR('u
.ti \w'  'u
int  \fBustr_utf8_valid\fR(const struct Ustr *);
.br
.in \w'  size_t  \fBustr_utf8_len\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_len\fR(const struct Ustr *);
.br
.in \w'  ssize_t  \fBustr_utf8_width\fR('u
.ti \w'  'u
ssize_t  \fBustr_utf8_width\fR(const struct Ustr *);
.br
.in \w'  size_t  \fBustr_utf8_chars2bytes\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_chars2bytes\fR(const struct Ustr *,  size_t,  size_t,  size_t *);
.br
.in \w'  size_t  \fBustr_utf8_bytes2chars\fR('u
.ti \w'  'u
size_t  \fBustr_utf8_bytes2chars\fR(const struct Ustr *,  size_t,  size_t,  size_t *);
.sp
.br
.in \w'  uintmax_t  \fBustr_parse_uintmaxx\fR('u
.ti \w'  'u
uintmax_t  \fBustr_parse_uintmaxx\fR(const struct Ustr *, size_t, unsigned int, uintmax_t, uintmax_t, const char *, size_t *, unsigned int *);
.br
.in \w'  uintmax_t  \fBustr_parse_uintmax\fR('u
.ti \w'  'u
uintmax_t  \fBustr_parse_uintmax\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.br
.in \w'  intmax_t  \fBustr_parse_intmax\fR('u
.ti \w'  'u
intmax_t  \fBustr_parse_intmax\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.br
.in \w'  unsigned long  \fBustr_parse_ulongx\fR('u
.ti \w'  'u
unsigned long  \fBustr_parse_ulongx\fR(const struct Ustr *,  size_t,  unsigned int,  unsigned long,  unsigned long, const char *,  size_t *, unsigned int *);
.br
.in \w'  unsigned long  \fBustr_parse_ulong\fR('u
.ti \w'  'u
unsigned long  \fBustr_parse_ulong\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.br
.in \w'  long  \fBustr_parse_long\fR('u
.ti \w'  'u
long  \fBustr_parse_long\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.br
.in \w'  unsigned int  \fBustr_parse_uint\fR('u
.ti \w'  'u
unsigned int  \fBustr_parse_uint\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.br
.in \w'  int  \fBustr_parse_int\fR('u
.ti \w'  'u
int  \fBustr_parse_int\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.br
.in \w'  unsigned short  \fBustr_parse_ushort\fR('u
.ti \w'  'u
unsigned short  \fBustr_parse_ushort\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.br
.in \w'  short  \fBustr_parse_short\fR('u
.ti \w'  'u
short  \fBustr_parse_short\fR(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
.sp
.br
.in \w'  int  \fBustr_sc_ensure_owner\fR('u
.ti \w'  'u
int  \fBustr_sc_ensure_owner\fR(struct Ustr **);
.br
.in \w'  int  \fBustr_sc_reverse\fR('u
.ti \w'  'u
int  \fBustr_sc_reverse\fR(struct Ustr **);
.br
.in \w'  int  \fBustr_sc_tolower\fR('u
.ti \w'  'u
int  \fBustr_sc_tolower\fR(struct Ustr **);
.br
.in \w'  int  \fBustr_sc_toupper\fR('u
.ti \w'  'u
int  \fBustr_sc_toupper\fR(struct Ustr **);
.br
.in \w'  char *\fBustr_sc_wstr\fR('u
.ti \w'  'u
char *\fBustr_sc_wstr\fR(struct Ustr **);
.sp
.br
.in \w'  int  \fBustr_add_b_uint16\fR('u
.ti \w'  'u
int  \fBustr_add_b_uint16\fR(struct Ustr **, uint_least16_t);
.br
.in \w'  int  \fBustr_add_b_uint32\fR('u
.ti \w'  'u
int  \fBustr_add_b_uint32\fR(struct Ustr **, uint_least32_t);
.br
.in \w'  int  \fBustr_add_b_uint64\fR('u
.ti \w'  'u
int  \fBustr_add_b_uint64\fR(struct Ustr **, uint_least64_t);
.sp
.br
.in \w'  uint_least16_t  \fBustr_parse_b_uint16\fR('u
.ti \w'  'u
uint_least16_t  \fBustr_parse_b_uint16\fR(const struct Ustr *, size_t);
.br
.in \w'  uint_least32_t  \fBustr_parse_b_uint32\fR('u
.ti \w'  'u
uint_least32_t  \fBustr_parse_b_uint32\fR(const struct Ustr *, size_t);
.br
.in \w'  uint_least64_t  \fBustr_parse_b_uint64\fR('u
.ti \w'  'u
uint_least64_t  \fBustr_parse_b_uint64\fR(const struct Ustr *, size_t);
.sp
.br
.in \w'  struct Ustr_pool *\fBustr_pool_make_pool\fR('u
.ti \w'  'u
struct Ustr_pool *\fBustr_pool_make_pool\fR(void);
.br
.in \w'  struct Ustr_pool *\fBustr_pool_make_subpool\fR('u
.ti \w'  'u
struct Ustr_pool *\fBustr_pool_make_subpool\fR(struct Ustr_pool *);
.br
.in \w'  void \fBustr_pool_free\fR('u
.ti \w'  'u
void \fBustr_pool_free\fR(struct Ustr_pool *);
.br
.in \w'  void \fBustr_pool_clear\fR('u
.ti \w'  'u
void \fBustr_pool_clear\fR(struct Ustr_pool *);

.ti
.HY
.SH "DESCRIPTION"
 A very simple overview is that you can use ustr_dup_cstr() to convert a C-style
to a Ustr, and ustr_cstr() to convert it back. You can also use USTR1() to
create constant/read-only strings, and USTR_SC_INIT_AUTO() to create strings
that use stack space upto a certain amount.
 Use is somewhat unique in that, by default, it has an average overhead of only
55% overhead over strdup(), for strings in the range of 0 to 20 bytes. Or, to
put it another way it only uses 8 bytes to store a 2 byte string where
strdup() uses 3.
.SH Creating read-only Ustr functions
.ti -2
.br
\fBFunction: \fR USTR()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Pointer to Ustr data
.br
Type\fB[1]\fR: void *

.br
\fBExplanation:\fR

.br
  This macro function is normally used with the empty string "".
.sp
\fBNote:\fR

.br
  There is basically just a simple cast behind the macro.

.ti -2
.br
\fBFunction: \fR USTRP()
.br
Returns: Ustrp string
.br
Type: struct Ustrp *

.br
Parameter\fB[1]\fR: Pointer to Ustr data
.br
Type\fB[1]\fR: void *

.br
\fBExplanation:\fR

.br
  This macro function is normally used with the empty string "".
.sp
\fBNote:\fR

.br
  There is basically just a simple cast behind the macro.

.ti -2
.br
\fBFunction: \fR USTR1()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Encoded number of the length of Ustr string
.br
Type\fB[1]\fR: symbol

.br
Parameter\fB[2]\fR: Data for Ustr string
.br
Type\fB[2]\fR: const char[]

.br
\fBExplanation:\fR

.br
  This macro function simplifies the creation of read-only Ustr string's. And is normally used like...

.Vb 4
  USTR1(\\x4, "abcd")

.Ve
 ...it is worth pointing out that running with debugging turned on
 (USTR_CONF_USE_ASSERT) will complain if the length isn't encoded correctly, as in...

.Vb 4
  USTR1(\\x3, "abcd")

.Ve
 ...here ustr_assert_valid() will fail, which is called before most functions do
 anything in debugging mode. Note also that extra debugging (USTR_CONF_USE_EOS_MARK) will still catch cases like...

.Vb 4
  USTR1(\\x3, "abc\\0d")

.Ve
 ...at least using debugging is esp. important if you are putting UTF-8
 characters into the strings.
.sp
\fBNote:\fR

.br
  Having ustr_ro() return true means that the Ustr cannot be written to without be reallocated into allocation space ... not that ustr_add() etc. will fail.

.ti -2
.br
\fBFunction: \fR USTR2()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Encoded 2nd byte of number of the length of Ustr string
.br
Type\fB[1]\fR: symbol

.br
Parameter\fB[2]\fR: Encoded 1st byte of number of the length of Ustr string
.br
Type\fB[2]\fR: symbol

.br
Parameter\fB[3]\fR: Data for Ustr string
.br
Type\fB[3]\fR: const char[]

.br
\fBExplanation:\fR

.br
  This function works in the same way as USTR1() but takes two length bytes, so the read-only string can be upto 65,535 (2**16 - 1) bytes in length.

.ti -2
.br
\fBFunction: \fR USTR4()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Encoded 4th byte of number of the length of Ustr string
.br
Type\fB[1]\fR: symbol

.br
Parameter\fB[2]\fR: Encoded 3rd byte of number of the length of Ustr string
.br
Type\fB[2]\fR: symbol

.br
Parameter\fB[3]\fR: Encoded 2nd byte of number of the length of Ustr string
.br
Type\fB[3]\fR: symbol

.br
Parameter\fB[4]\fR: Encoded 1st byte of number of the length of Ustr string
.br
Type\fB[4]\fR: symbol

.br
Parameter\fB[5]\fR: Data for Ustr string
.br
Type\fB[5]\fR: const char[]

.br
\fBExplanation:\fR

.br
  This function works in the same way as USTR1() but takes four length bytes, so the read-only string can be upto 2**32 - 1 bytes in length.

.ti -2
.br
\fBFunction: \fR USTRP1()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Encoded number of the length of Ustr string
.br
Type\fB[1]\fR: symbol

.br
Parameter\fB[2]\fR: Data for Ustr string
.br
Type\fB[2]\fR: const char[]

.br
\fBExplanation:\fR

.br
  This function works like USTR1(), but returns a Ustrp instead.

.ti -2
.br
\fBFunction: \fR USTRP2()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Encoded 2nd byte of number of the length of Ustr string
.br
Type\fB[1]\fR: symbol

.br
Parameter\fB[2]\fR: Encoded 1st byte of number of the length of Ustr string
.br
Type\fB[2]\fR: symbol

.br
Parameter\fB[3]\fR: Data for Ustr string
.br
Type\fB[3]\fR: const char[]

.br
\fBExplanation:\fR

.br
  This function works like USTR4(), but returns a Ustrp instead.

.ti -2
.br
\fBFunction: \fR USTRP4()
.br
Returns: Ustrp string
.br
Type: struct Ustrp *

.br
Parameter\fB[1]\fR: Encoded 4th byte of number of the length of Ustrp string
.br
Type\fB[1]\fR: symbol

.br
Parameter\fB[2]\fR: Encoded 3rd byte of number of the length of Ustrp string
.br
Type\fB[2]\fR: symbol

.br
Parameter\fB[3]\fR: Encoded 2nd byte of number of the length of Ustrp string
.br
Type\fB[3]\fR: symbol

.br
Parameter\fB[4]\fR: Encoded 1st byte of number of the length of Ustrp string
.br
Type\fB[4]\fR: symbol

.br
Parameter\fB[5]\fR: Data for Ustr string
.br
Type\fB[5]\fR: const char[]

.br
\fBExplanation:\fR

.br
  This function works like USTR2(), but returns a Ustrp instead.

.SH Creating fixed Ustr functions
.ti -2
.br
\fBFunction: \fR USTR_SIZE_FIXED()
.br
Returns: Size of area of memory
.br
Type: size_t

.br
Parameter\fB[1]\fR: Size of area of memory
.br
Type\fB[1]\fR: size_t

.br
\fBExplanation:\fR

.br
  This macro function is replaced by a static conversion from the max length desired (Parameter[1]) to the storage size needed. In other words it works out what ustr_size_overhead() will be, and adds that value.
.sp
\fBNote:\fR

.br
  This is useful is you want a small fixed size allocation, as you can declare it like so:

.br
  char buf[USTR_SIZE_FIXED(4)];
.Ve
 ...to give you exactly 4 bytes as a maximum, this is esp. useful if you want
 a limited (ustr_limited() == USTR_TRUE) Ustr string.

.ti -2
.br
\fBFunction: \fR ustr_init_fixed()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Pointer to area of memory to use as a Ustr string
.br
Type\fB[1]\fR: void *

.br
Parameter\fB[2]\fR: Size of area of memory
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Whether the fixed size Ustr should be limited
.br
Type\fB[3]\fR: int

.br
Parameter\fB[4]\fR: The initial length of the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This creates a new Ustr string, which is "fixed". This means the Ustr storage is managed outside of the ustr_* API, it is often used for stack allocated strings.
.br
  As you add data to the Ustr past the size allowed via. the fixed storge the Ustr will automatically be converted into an allocated Ustr. So if this is possible you should always call ustr_free(), as this does nothing if given a fixed size Ustr.
.sp
\fBNote:\fR

.br
  For simplicity you probably want to use USTR_SC_INIT_AUTO() when possible.

.ti -2
.br
\fBFunction: \fR USTR_SC_INIT_AUTO()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Area of memory to use as a Ustr string
.br
Type\fB[1]\fR: char[]

.br
Parameter\fB[2]\fR: Whether the fixed size Ustr should be limited
.br
Type\fB[2]\fR: int

.br
Parameter\fB[3]\fR: The initial length of the Ustr
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This calls ustr_init_fixed() with sizeof() the area of memory (Parameter[1]) as the second argument.
.sp
\fBNote:\fR

.br
  This does mean that the first argument must be the correct size, as far as sizeof() is concerned, as in...

.Vb 4
 char buf_sz[1024];
 Ustr *s1 = USTR_SC_INIT_AUTO(buf_sz, USTR_FALSE, 0);

.Ve
 ...so passing pointers to memory from malloc() will probably just return NULL.


.SH Creating allocated Ustr functions
.ti -2
.br
\fBFunction: \fR ustr_init_alloc()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Pointer to area of memory to use as a Ustr string
.br
Type\fB[1]\fR: void *

.br
Parameter\fB[2]\fR: Size of area of memory
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Whether Ustr should store the size
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Number of bytes to use for references
.br
Type\fB[4]\fR: size_t

.br
Parameter\fB[5]\fR: Whether the Ustr should use exact allocations
.br
Type\fB[5]\fR: int

.br
Parameter\fB[6]\fR: Whether the Ustr should have the "enomem" flag set
.br
Type\fB[6]\fR: int

.br
Parameter\fB[7]\fR: The initial length of the Ustr
.br
Type\fB[7]\fR: size_t

.br
\fBExplanation:\fR

.br
  This creates a new Ustr string, you should have allocated the data via.  USTR_CONF_MALLOC() or bad things will happen if the Ustr string is ever free'd or reallocated.

.ti -2
.br
\fBFunction: \fR ustr_dupx_empty()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Size of allocated storage
.br
Type\fB[1]\fR: size_t

.br
Parameter\fB[2]\fR: Number of bytes to use for reference count
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Exact memory allocation flag
.br
Type\fB[3]\fR: int

.br
Parameter\fB[4]\fR: ENOMEM, memory error flag
.br
Type\fB[4]\fR: int

.br
\fBExplanation:\fR

.br
  This function creates an empty Ustr, owned by you, that is allocated from system memory, or it returns NULL.
.br
  The size is the desired allocation size for the entire Ustr, including overhead for metadata. This value will be rounded up, if it's too small, so passing 1 as the size means you want a stored size but to allocate the smallest amount of memory possible.
.br
  The exact memory allocation flag says if the Ustr should round allocations up to the nearest half power of two or should be no more than needed.
.br
  The ENOMEM memory error flag sets the iniital state of the user visible flag for memory allocation errors. Eg. ustr_enomem(), ustr_setf_enomem_clr() and ustr_setf_enomem_err()
.sp
\fBNote:\fR

.br
  The reference byte count can only be one of the following values: 0, 1, 2 or 4, or 8 (on environments with a 64bit size_t).
.br
  It can be useful to ensure that the Ustr is in system memory, so that you can add things to it and check for errors with ustr_enomem().
.br
  If you chose to store the allocated size in the Ustr then the number of bytes allocated for the reference count will be a minimum of 2.

.ti -2
.br
\fBFunction: \fR ustr_dup_empty()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Nothing
.br
Type\fB[1]\fR: void

.br
\fBExplanation:\fR

.br
  This function is the same as calling ustr_dupx_empty() with the current set of default options.

.ti -2
.br
\fBFunction: \fR ustr_dupx_undef()
.br
Returns: Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Size of allocated storage
.br
Type\fB[1]\fR: size_t

.br
Parameter\fB[2]\fR: Number of bytes to use for reference count
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Exact memory allocations
.br
Type\fB[3]\fR: int

.br
Parameter\fB[4]\fR: ENOMEM, memory error flag
.br
Type\fB[4]\fR: int

.br
Parameter\fB[5]\fR: Length of new undefined data
.br
Type\fB[5]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like you called ustr_dupx_empty() and then ustr_add_undef().

.ti -2
.br
\fBFunction: \fR ustr_dup_undef()
.br
Returns: Pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Length of new undefined data
.br
Type\fB[1]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function is the same as calling ustr_dupx_undef() with the current set of default options.

.ti -2
.br
\fBFunction: \fR ustr_dup()
.br
Returns: A pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function tries to increase the reference count on the passed Ustr string, and if that succeeds returns that as an argument. If that fails it tries creates a new Ustr string that looks identical to the old Ustr string, apart from the reference count.
.sp
\fBNote:\fR

.br
  Because the new Ustr string is configured identically to the old Ustr string this means the result can be very different to what you get if you call ustr_dup_buf() with ustr_cstr() and ustr_len() from the original string where the configuration would be whatever the default is.
.br
  Esp. worth of note is that if you ustr_dup() a Ustr string with an explicit size of 900 but a length of 1, and the reference count is full the returned Ustr string will have a size of 900 bytes and so will have allocated a little over that. ustr_dup_buf(), even with a sized configuration would only allocate about 12 bytes and have a size a little less than that.

.ti -2
.br
\fBFunction: \fR ustr_dupx()
.br
Returns: Pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Size of allocated storage
.br
Type\fB[1]\fR: size_t

.br
Parameter\fB[2]\fR: Number of bytes to use for reference count
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Exact memory allocations
.br
Type\fB[3]\fR: int

.br
Parameter\fB[4]\fR: ENOMEM, memory error flag
.br
Type\fB[4]\fR: int

.br
Parameter\fB[5]\fR: Pointer to a constant Ustr string
.br
Type\fB[5]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function tries to add a reference if the value of the size, reference bytes, exact memory allocations and ENOMEM are the same as those in the passed Ustr string (Parameter[5]). If the comparison fails or the addition of a reference fails it works like ustr_dupx_buf() using ustr_cstr() and ustr_len().

.ti -2
.br
\fBFunction: \fR ustr_sc_dupx()
.br
Returns: Pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Size of allocated storage
.br
Type\fB[1]\fR: size_t

.br
Parameter\fB[2]\fR: Number of bytes to use for reference count
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Exact memory allocations
.br
Type\fB[3]\fR: int

.br
Parameter\fB[4]\fR: ENOMEM, memory error flag
.br
Type\fB[4]\fR: int

.br
Parameter\fB[5]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[5]\fR: struct Ustr **

.br
\fBExplanation:\fR

.br
  This function works like calling ustr_dupx(), but if the reference count is maxed out then and so a new Ustr string is allocated then that is stored in the passed argument (Parameter[1]) and the "old" Ustr string is returned.
.br
  If the configurations of the new Ustr string and the old Ustr string are not the same, this function works identically to ustr_dupx().
.sp
\fBNote:\fR

.br
  The reason to use this is that if you have a "main" Ustr string pointer that a lot of things are getting references too then when the reference count maxes out you'll degrade into worst case behaviour which acts as though there are no reference counts. This function stops that problem.
.br
  As an example, if you have a 1 byte reference count and have 255 * 2 references then using ustr_dupx() will create 256 Ustr strings using this function will create 4 Ustr strings.

.ti -2
.br
\fBFunction: \fR ustr_sc_dup()
.br
Returns: A pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR

.br
  This function works like calling ustr_dupx(), but if the reference count is maxed out then and so a new Ustr string has been allocated then that is stored in the passed argument (Parameter[1]) and the "old" Ustr string is returned.
.sp
\fBNote:\fR

.br
  The reason to use this is that if you have a "main" Ustr string pointer that a lot of things are getting references too then when the reference count maxes out you'll degrade into worst case behaviour which acts as though there are no reference counts. This function stops that problem.
.br
  As an example, if you have a 1 byte reference count and have 255 * 2 references then using ustr_dup() will create 256 Ustr strings using this function will create 4 Ustr strings.

.SH Deleting a Ustr, or data within a Ustr
.ti -2
.br
\fBFunction: \fR ustr_free()
.br
Returns: Nothing
.br
Type: void 

.br
Parameter\fB[1]\fR: Pointer to a Ustr
.br
Type\fB[1]\fR: struct Ustr *

.br
\fBExplanation:\fR

.br
  This function decrements the reference count on a Ustr, if there is one, and free's it if it is allocated and the reference count becomes zero.
.ti -2
.br
\fBFunction: \fR ustrp_free()
.br
Returns: Nothing
.br
Type: void 

.br
Parameter\fB[1]\fR: Pointer to a Ustr_pool object
.br
Type\fB[1]\fR: struct Ustr_pool *

.br
Parameter\fB[2]\fR: Pointer to a Ustrp (pool allocated Ustr)
.br
Type\fB[2]\fR: struct Ustrp *

.br
\fBExplanation:\fR

.br
  This function works like ustr_free() but calls the pool_free member function of the Ustr_pool (Parameter[1]) instead of the system free.

.ti -2
.br
\fBFunction: \fR ustr_sc_free()
.br
Returns: Nothing
.br
Type: void 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR

.br
  This function calls ustr_free() and then sets the pointer (Parameter[1]) to USTR_NULL, which is a noop when passed to ustr_free(). This can be used to help prevent "double free" errors.

.ti -2
.br
\fBFunction: \fR ustr_sc_free2()
.br
Returns: Nothing
.br
Type: void 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Pointer to a Ustr string
.br
Type\fB[2]\fR: struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_sc_free() but instead of setting the pointer (Parameter[1]) to USTR_NULL it sets it to the Ustr string (Parameter[2]).
.sp
\fBNote:\fR

.br
  The passed value shouldn't be USTR_NULL, and in debugging mode the function will assert() that it isn't.

.ti -2
.br
\fBFunction: \fR ustr_sc_free_shared()
.br
Returns: Nothing
.br
Type: void 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR

.br
  This function is a simple way to "free" a Ustr string that has been shared (ustr_shared() returns USTR_TRUE), normally ustr_free() is ignored on a shared Ustr string. It just calls ustr_setf_owner() and then ustr_sc_free().

.ti -2
.br
\fBFunction: \fR ustr_del()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Length to delete from the Ustr
.br
Type\fB[2]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function deletes data from the end of Ustr, possibly re-sizing the Ustr at the same time.
.sp
\fBNote:\fR

.br
  The Ustr is never re-sized when the size is stored explicitly, so the pointer never changes.

.ti -2
.br
\fBFunction: \fR ustr_del_subustr()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Position in the Ustr
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Length to delete from the Ustr
.br
Type\fB[3]\fR:  size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_del() but can delete an arbitrary section of the Ustr.

.ti -2
.br
\fBFunction: \fR ustr_sc_del()
.br
Returns: Nothing
.br
Type: void 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR

.br
  This function is like calling ustr_del() with ustr_len() as the length, however if that fails it does a ustr_free() and then sets the pointer to USTR("").
.sp
\fBNote:\fR

.br
  While the benifit is that you don't have to check for memory failure errors, if there is a memory failure and you have a non-default configuration the configuration will revert back to the default.

.SH Adding data to a Ustr
.ti -2
.br
\fBFunction: \fR ustr_add_undef()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Length of new undefined data
.br
Type\fB[2]\fR: size_t

.br
\fBExplanation:\fR

.br
  The Ustr string is expanded (possibly reallocated) so that it can contain length (Parameter[2]) extra data, if the length is not zero the Ustr will be writable. Or it'll return USTR_FALSE (zero) on failure.

.ti -2
.br
\fBFunction: \fR ustr_add_buf()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Pointer to data
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of data
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_add_undef() and then copied the data into the new undefined spacee.

.ti -2
.br
\fBFunction: \fR ustr_add_cstr()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Pointer to constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_add_buf() and passed strlen() as the length.

.ti -2
.br
\fBFunction: \fR ustr_add()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function mostly works as if you had called ustr_add_buf() with the ustr_cstr() and ustr_len() values of the Ustr string to be added.
.sp
\fBNote:\fR

.br
  If the Ustr string is zero length and isn't writable this function may just add a reference, this is fine for Ustr strings that are "constant" because if the Ustr is read-only then the memory will not be written to.

.ti -2
.br
\fBFunction: \fR ustr_add_subustr()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Position in the Ustr
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Length to add from the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function mostly works as if you had called ustr_add_buf() with the ustr_cstr() + position - 1 and length values of the Ustr string to be added.
.sp
\fBNote:\fR

.br
  If the position is 1 and the length is the length of the Ustr string then it just calls ustrr_add().

.ti -2
.br
\fBFunction: \fR ustr_add_rep_chr()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Byte value of data
.br
Type\fB[2]\fR: char

.br
Parameter\fB[3]\fR: Length of bytes as data
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_add_undef() and then copied the byte value to each position.

.SH Setting a Ustr to some data
.ti -2
.br
\fBFunction: \fR ustr_set_undef()
.br
Returns: Success or failure 
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  size_t
.br
Type\fB[2]\fR:  size_t

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_del() for the entire string and the ustr_add_undef().

.ti -2
.br
\fBFunction: \fR ustr_set_empty()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_del() for the entire string, however the string will be allocated if this completes.

.ti -2
.br
\fBFunction: \fR ustr_set_buf()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  const void *
.br
Type\fB[2]\fR:  const void *

.br
Parameter\fB[3]\fR:  size_t
.br
Type\fB[3]\fR:  size_t

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_del() for the entire string and the ustr_add_buf().

.ti -2
.br
\fBFunction: \fR ustr_set_cstr()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  const char *
.br
Type\fB[2]\fR:  const char *

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_del() for the entire string and the ustr_add_cstr().

.ti -2
.br
\fBFunction: \fR ustr_set()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_del() for the entire string and the ustr_add().

.ti -2
.br
\fBFunction: \fR ustr_set_subustr()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Position in the Ustr
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Length to set from the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_del() for the entire string and the ustr_add_subustr().

.ti -2
.br
\fBFunction: \fR ustr_set_rep_chr()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Byte value of data
.br
Type\fB[2]\fR: char

.br
Parameter\fB[3]\fR: Length of bytes as data
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works as if you had called ustr_del() for the entire string and the ustr_add_rep_chr().

.SH Resizing a sized Ustr
.ti -2
.br
\fBFunction: \fR ustr_realloc()
.br
Returns: Success or failure
.br
Type: int

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Size of allocation
.br
Type\fB[2]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function is re-sizes the Ustr to the specified size (Parameter[2]).
.br
  This is mostly used to shrink a sized Ustr that is now significantly smaller than it once was. Although this function can also grow a Ustr.
.sp
\fBNote:\fR

.br
  To have a size that isn't implied from the length the Ustr must store a size value as well as a length (ustr_sized() must return USTR_TRUE).

.SH Adding, duplicating and setting formatted data to a Ustr
.ti -2
.br
\fBFunction: \fR ustr_add_vfmt_lim()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Limit of data to add
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Variable argument list variable
.br
Type\fB[4]\fR: va_list

.br
\fBExplanation:\fR

.br
  This function works like calling the system vsnprintf() with the limit (Parameter[2]) as the limit to vsnprintf() and then calling ustr_add_buf().

.ti -2
.br
\fBFunction: \fR ustr_add_vfmt()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
Parameter\fB[3]\fR: Variable argument list variable, from va_start()
.br
Type\fB[3]\fR: va_list

.br
\fBExplanation:\fR

.br
  This function works like calling the system vsnprintf() and then calling ustr_add_buf().

.ti -2
.br
\fBFunction: \fR ustr_add_fmt()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
Parameter\fB[3]\fR: Options depending on value of Parameter[2]
.br
Type\fB[3]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling the system snprintf() and then calling ustr_add_buf().

.ti -2
.br
\fBFunction: \fR ustr_add_fmt_lim()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Limit of data to add
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Options depending on value of Parameter[3]
.br
Type\fB[4]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling the system snprintf() with the limit (Parameter[2]) as the limit to snprintf() and then calling ustr_add_buf().

.ti -2
.br
\fBFunction: \fR ustr_dupx_fmt_lim()
.br
Returns: Pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Size of allocated storage
.br
Type\fB[1]\fR: size_t

.br
Parameter\fB[2]\fR: Number of bytes to use for reference count
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Exact memory allocations
.br
Type\fB[3]\fR: int

.br
Parameter\fB[4]\fR: ENOMEM, memory error flag
.br
Type\fB[4]\fR: int

.br
Parameter\fB[5]\fR: Limit of data to dup
.br
Type\fB[5]\fR: size_t

.br
Parameter\fB[6]\fR: Pointer to a constant Ustr string
.br
Type\fB[6]\fR: const char *

.br
Parameter\fB[7]\fR: Options depending on value of Parameter[6]
.br
Type\fB[7]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling the system snprintf() with the limit (Parameter[2]) as the limit to snprintf() and then calling ustr_dupx_buf().

.ti -2
.br
\fBFunction: \fR ustr_dup_fmt_lim()
.br
Returns: Pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Limit of data to dup
.br
Type\fB[1]\fR: size_t

.br
Parameter\fB[2]\fR: Pointer to a constant Ustr string
.br
Type\fB[2]\fR: const char *

.br
Parameter\fB[3]\fR: Options depending on value of Parameter[2]
.br
Type\fB[3]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling the system snprintf() with the limit (Parameter[2]) as the limit to snprintf() and then calling ustr_dup_buf().

.ti -2
.br
\fBFunction: \fR ustr_dupx_fmt()
.br
Returns: Pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Size of allocated storage
.br
Type\fB[1]\fR: size_t

.br
Parameter\fB[2]\fR: Number of bytes to use for reference count
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Exact memory allocations
.br
Type\fB[3]\fR: int

.br
Parameter\fB[4]\fR: ENOMEM, memory error flag
.br
Type\fB[4]\fR: int

.br
Parameter\fB[5]\fR: Pointer to a constant Ustr string
.br
Type\fB[5]\fR: const char *

.br
Parameter\fB[6]\fR: Options depending on value of Parameter[5]
.br
Type\fB[6]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling the system snprintf() and then calling ustr_dup_bufx().

.ti -2
.br
\fBFunction: \fR ustr_dup_fmt()
.br
Returns: Pointer to a Ustr string
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Pointer to a constant Ustr string
.br
Type\fB[1]\fR: const char *

.br
Parameter\fB[2]\fR: Options depending on value of Parameter[1]
.br
Type\fB[2]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling the system snprintf() and then calling ustr_dup_buf().

.ti -2
.br
\fBFunction: \fR ustr_set_vfmt_lim()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Limit of data to set
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Variable argument list variable, from va_start()
.br
Type\fB[4]\fR: va_list

.br
\fBExplanation:\fR

.br
  This function works like calling ustr_del() for all the data and then ustr_add_vfmt_lim().

.ti -2
.br
\fBFunction: \fR ustr_set_vfmt()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
Parameter\fB[3]\fR: Variable argument list variable, from va_start()
.br
Type\fB[3]\fR: va_list

.br
\fBExplanation:\fR

.br
  This function works like calling ustr_del() for all the data and then ustr_add_vfmt().

.ti -2
.br
\fBFunction: \fR ustr_set_fmt_lim()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Limit of data to set
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Options depending on value of Parameter[3]
.br
Type\fB[4]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling ustr_del() for all the data and then ustr_add_fmt_lim().

.ti -2
.br
\fBFunction: \fR ustr_set_fmt()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
Parameter\fB[3]\fR: Options depending on value of Parameter[2]
.br
Type\fB[3]\fR: ...

.br
\fBExplanation:\fR

.br
  This function works like calling ustr_del() for all the data and then ustr_add_fmt().

.SH Accessing the "variables" of a Ustr
.ti -2
.br
\fBFunction: \fR ustr_len()
.br
Returns: The length of the Ustr
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function returns the length of the data within the Ustr, much like strlen() but without getting the value wrong in the case of extra NIL bytes.

.ti -2
.br
\fBFunction: \fR ustr_cstr()
.br
Returns: Read-only pointer to the start of data in the Ustr
.br
Type: const char *

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function returns a read-only pointer to the start of the data of the Ustr string. Due to there always being a terminating NIL byte in a Ustr, this is also a valid C-style string.

.ti -2
.br
\fBFunction: \fR ustr_wstr()
.br
Returns: Writable pointer to the start of data in the Ustr, or NULL
.br
Type: char *

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: struct Ustr *

.br
\fBExplanation:\fR

.br
  This function returns a writable pointer to the start of the data of the Ustr string. Due to there always being a terminating NIL byte in a Ustr, this is also a valid C-style string.
.br
  If the ustr is read-only (ustr_ro() == USTR_TRUE) then this function will return NULL.
.sp
\fBNote:\fR

.br
  Unless the string is owned (ustr_owner() == USTR_TRUE) it can be a very bad idea to use this to change data, as then all references will be updated. See ustr_sc_wstr().

.ti -2
.br
\fBFunction: \fR ustr_alloc()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if the Ustr is currently in allocated storage.

.ti -2
.br
\fBFunction: \fR ustr_exact()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if the Ustr is doing exact allocations, so as the Ustr grows it will only have storage allocated exactly as required and not in half powers of two.
.sp
\fBNote:\fR

.br
  This will always be USTR_FALSE for read-only Ustr strings (ustr_ro() == USTR_TRUE), even though the default may be to used exact sized allocations when  adding data to them etc.

.ti -2
.br
\fBFunction: \fR ustr_sized()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if the Ustr stores an explicit allocation size, if not the size is implied as the next highest half power of two.

.ti -2
.br
\fBFunction: \fR ustr_ro()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if the Ustr is current in read-only storage.
.br
  Read-only storage is not writable but can be referenced via. ustr_dup() an infinite amount of times.

.ti -2
.br
\fBFunction: \fR ustr_fixed()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if the Ustr is current in fixed size storage.
.br
  Fixed size storage is writable but cannot be referenced.
.sp
\fBNote:\fR

.br
  Fixed size storage always explicitly stores the size of the storage.

.ti -2
.br
\fBFunction: \fR ustr_enomem()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function just returns the value of the user settable flag in the Ustr. It can be set via. ustr_setf_enomem_err() and cleared by ustr_setf_enomem_clr().
.br
  This function is automatically set to on whever a memory allocation failure happens for a Ustr.
.sp
\fBNote:\fR

.br
  If a Ustr is referenced multiple times, ustr_setf_enomem_err() will fail.
.br
  This always fails for Ustr's in read-only storage.

.ti -2
.br
\fBFunction: \fR ustr_shared()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if the Ustr is in the "shared" mode. It can be set via. ustr_setf_shared() and cleared by ustr_setf_owner() on allocated Ustr's.
.br
  Shared mode means that a Ustr can be referenced and unreferenced an infinite number of times.
.sp
\fBNote:\fR

.br
  This always succeeds for Ustr's in read-only storage.
.br
  This always fails for Ustr's in fixed size storage.

.ti -2
.br
\fBFunction: \fR ustr_limited()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if the Ustr is currently in fixed size storage and cannot move to allocated storage.
.sp
\fBNote:\fR

.br
  This always fails for Ustr's in allocated storage.
.br
  This always fails for Ustr's in read-only storage.

.ti -2
.br
\fBFunction: \fR ustr_owner()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function says if there is only a single reference to the Ustr string.
.sp
\fBNote:\fR

.br
  This always fails for Ustr's in read-only storage.
.br
  This always succeeds for Ustr's in fixed size storage.

.ti -2
.br
\fBFunction: \fR ustr_size()
.br
Returns: size_t 
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function calculates the maximum amount of data that could be stored (Ie. the max ustr_len()) without having to re-size the Ustr string.

.ti -2
.br
\fBFunction: \fR ustr_size_alloc()
.br
Returns: size_t 
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function returns the size of the storage for the Ustr.

.ti -2
.br
\fBFunction: \fR ustr_size_overhead()
.br
Returns: size_t 
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function returns the difference between the size of the storage and the maximum amount of data that could be stored without having to re-size the Ustr string.

.SH Setting the "flags" of a Ustr
.ti -2
.br
\fBFunction: \fR ustr_setf_enomem_err()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr *

.br
\fBExplanation:\fR

.br
  This function sets the enomem flag, which can be observed via. the ustr_enomem() function.
.br
  The implication of setting this flag is that a memory error has occured in a previous function call on this Ustr.
.sp
\fBNote:\fR

.br
  This function fails if ustr_owner() fails for the Ustr.

.ti -2
.br
\fBFunction: \fR ustr_setf_enomem_clr()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr *

.br
\fBExplanation:\fR

.br
  This function clears the enomem flag, which can be observed via. the ustr_enomem() function.
.br
  The implication of this flag being set is that a memory error has occured in a previous function call on this Ustr, so on clearing the flag you should know you have brought the Ustr back to a known state.
.sp
\fBNote:\fR

.br
  This function fails if ustr_owner() fails for the Ustr.

.ti -2
.br
\fBFunction: \fR ustr_setf_share()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr *

.br
\fBExplanation:\fR

.br
  This function sets the shared mode, which can be observed via. the ustr_shared() function.
.br
  This is used on a Ustr so that it can have more references than it is able to hold in it's reference count. After this call the Ustr can be referenced and unreferenced an infinite number of times.
.sp
\fBNote:\fR

.br
  After this call the Ustr will never be deleted until ustr_setf_owner() is called.
.br
  This function fails if ustr_alloc() fails for the Ustr.

.ti -2
.br
\fBFunction: \fR ustr_setf_owner()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr *

.br
\fBExplanation:\fR

.br
  This function removes the shared mode, which can be observed via. the ustr_shared() function.
.br
  This is used so that a Ustr in shared mode can be free'd.
.sp
\fBNote:\fR

.br
  This function fails if ustr_alloc() fails for the Ustr.

.SH Comparing data in a Ustr
.ti -2
.br
\fBFunction: \fR ustr_cmp_buf()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like memcmp() on the Ustr and the passed data.

.ti -2
.br
\fBFunction: \fR ustr_cmp()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_buf() but with the data from ustr_cstr() and the length from ustr_len().

.ti -2
.br
\fBFunction: \fR ustr_cmp_subustr()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Position in the Ustr
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Length to compare from the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp() but with a limit on the data and length.

.ti -2
.br
\fBFunction: \fR ustr_cmp_cstr()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_buf() but with a length from strlen().

.ti -2
.br
\fBFunction: \fR ustr_cmp_fast_buf()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_buf() but the order of comparison is optimized for speed, but is much less friendly to humans.

.ti -2
.br
\fBFunction: \fR ustr_cmp_fast()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_fast_buf() but with the data from ustr_cstr() and the length from ustr_len().

.ti -2
.br
\fBFunction: \fR ustr_cmp_fast_subustr()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Position in the Ustr
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Length to compare from the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_fast() but with a limit on the data and length.

.ti -2
.br
\fBFunction: \fR ustr_cmp_fast_cstr()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_fast_buf() but with a length from strlen().

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_buf()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_buf() but the order of comparison ignores ASCII case.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_case_buf() but with the data from ustr_cstr() and the length from ustr_len().

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_subustr()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Position in the Ustr
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Length to compare from the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_case() but with a limit on the data and length.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_cstr()
.br
Returns: Less then zero, zero or greater than zero depending on comparison
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_case_buf() but with a length from strlen().

.ti -2
.br
\fBFunction: \fR ustr_cmp_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_buf_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_buf() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_subustr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Position in the Ustr
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Length to compare from the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_subustr() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_cstr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_cstr() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_case() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_buf_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_case_buf() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_subustr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Position in the Ustr
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Length to compare from the Ustr
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_case_subustr() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_cstr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_case_cstr() against 0.

.ti -2
.br
\fBFunction: \fR ustr_cmp_prefix_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp() against 0, but the comparison is limited to the length of the right hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_prefix_buf_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_buf() against 0, but the comparison is limited to the length of the right hand side (Parameter[3]).

.ti -2
.br
\fBFunction: \fR ustr_cmp_prefix_cstr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_cstr() against 0, but the comparison is limited to the length of the right hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_prefix_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_case() against 0, but the comparison is limited to the length of the right hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_prefix_buf_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_case_buf() against 0, but the comparison is limited to the length of the right hand side (Parameter[3]).

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_prefix_cstr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like comparing ustr_cmp_case_cstr() against 0, but the comparison is limited to the length of the right hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_suffix_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_prefix_eq() but compares the end of the left hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_suffix_buf_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_prefix_buf_eq() but compares the end of the left hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_suffix_cstr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_prefix_cstr_eq() but compares the end of the left hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_suffix_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant Ustr string
.br
Type\fB[2]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_case_prefix_eq() but compares the end of the left hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_suffix_buf_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to constant bytes, to compare
.br
Type\fB[2]\fR: const void *

.br
Parameter\fB[3]\fR: Length of comparison bytes
.br
Type\fB[3]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_case_prefix_buf_eq() but compares the end of the left hand side.

.ti -2
.br
\fBFunction: \fR ustr_cmp_case_suffix_cstr_eq()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: A pointer to a constant C-style string
.br
Type\fB[2]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cmp_case_prefix_cstr_eq() but compares the end of the left hand side.

.SH Searching for data in a Ustr
.ti -2
.br
\fBFunction: \fR ustr_srch_chr_fwd()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Byte data to search for
.br
Type\fB[3]\fR: char

.br
\fBExplanation:\fR

.br
  This function searches for the data (Parameter[3]) in the Ustr, skipping an offset (Parameter[2]) number of bytes.

.ti -2
.br
\fBFunction: \fR ustr_srch_chr_rev()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR:  size_t

.br
Parameter\fB[3]\fR: Byte data to search for
.br
Type\fB[3]\fR: char

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_chr_fwd() but it searches from the end of the string to the beginning.

.ti -2
.br
\fBFunction: \fR ustr_srch_buf_fwd()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to data to search for
.br
Type\fB[3]\fR: const void *

.br
Parameter\fB[4]\fR: Length of the data to search for
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function searches for the data (Parameter[3]) of length (Parameter[4]) in the Ustr, skipping an offset (Parameter[2]) number of bytes.

.ti -2
.br
\fBFunction: \fR ustr_srch_buf_rev()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to data to search for
.br
Type\fB[3]\fR: const void *

.br
Parameter\fB[4]\fR: Length of the data to search for
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_buf_fwd() but it searches from the end of the string to the beginning.

.ti -2
.br
\fBFunction: \fR ustr_srch_fwd()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string, to search for
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_buf_fwd() but it gets the data pointer by calling ustr_cstr() and the length by calling ustr_len() on the passed Ustr (Parameter[3]).

.ti -2
.br
\fBFunction: \fR ustr_srch_rev()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string, to search for
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_fwd() but it searches from the end of the string to the beginning.

.ti -2
.br
\fBFunction: \fR ustr_srch_cstr_fwd()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to C-style string data, to search for
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_buf_fwd() but it gets the length by calling strlen() on the passed data (Parameter[3]).

.ti -2
.br
\fBFunction: \fR ustr_srch_cstr_rev()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to C-style string data, to search for
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_cstr_fwd() but it searches from the end of the string to the beginning.

.ti -2
.br
\fBFunction: \fR ustr_srch_subustr_fwd()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string
.br
Type\fB[3]\fR: const struct Ustr *

.br
Parameter\fB[4]\fR: Position in the Ustr
.br
Type\fB[4]\fR: size_t

.br
Parameter\fB[5]\fR: Length of data to search, from the Ustr
.br
Type\fB[5]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_fwd() but it moves the data to start at the correct position and limits the length to the value specified.

.ti -2
.br
\fBFunction: \fR ustr_srch_subustr_rev()
.br
Returns: Position in the Ustr, or zero if not found
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start searching at
.br
Type\fB[2]\fR:  size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string
.br
Type\fB[3]\fR: const struct Ustr *

.br
Parameter\fB[4]\fR: Position in the Ustr
.br
Type\fB[4]\fR: size_t

.br
Parameter\fB[5]\fR: Length of data to search, from the Ustr
.br
Type\fB[5]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_srch_rev() but it moves the data to start at the correct position and limits the length to the value specified.

.SH Span lengths of data in a Ustr
.ti -2
.br
\fBFunction: \fR ustr_spn_chr_fwd()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Byte data
.br
Type\fB[3]\fR: char

.br
\fBExplanation:\fR

.br
  This function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that are equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_spn_chr_rev()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Byte data
.br
Type\fB[3]\fR: char

.br
\fBExplanation:\fR

.br
  This function returns the length of the end of the Ustr (Parameter[1]) that only contains bytes that are equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_spn_chrs_fwd()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Array of byte data
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of byte data
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that are equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_spn_chrs_rev()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Array of byte data
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of byte data
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function returns the length of the end of the Ustr (Parameter[1]) that only contains bytes that are equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_spn_fwd()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string, containing spanning bytes
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_spn_buf_fwd() but passing ustr_cstr() and ustr_len()

.ti -2
.br
\fBFunction: \fR ustr_spn_rev()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string, containing spanning bytes
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_spn_buf_rev() but passing ustr_cstr() and ustr_len()

.ti -2
.br
\fBFunction: \fR ustr_spn_cstr_fwd()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string, containing spanning bytes
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_spn_buf_fwd() but passing strlen() for the length.

.ti -2
.br
\fBFunction: \fR ustr_spn_cstr_rev()
.br
Returns: Number of bytes in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string, containing spanning bytes
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_spn_buf_rev() but passing strlen() for the length.

.ti -2
.br
\fBFunction: \fR ustr_cspn_chr_fwd()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Byte data
.br
Type\fB[3]\fR: char

.br
\fBExplanation:\fR

.br
  This function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that are not equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_cspn_chr_rev()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Byte data
.br
Type\fB[3]\fR: char

.br
\fBExplanation:\fR

.br
  This function returns the length of the end of the Ustr (Parameter[1]) that only contains bytes that are not equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_cspn_chrs_fwd()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Array of byte data
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of byte data
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that are not equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_cspn_chrs_rev()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Array of byte data
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of byte data
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function returns the length of the end of the Ustr (Parameter[1]) that only contains bytes that are not equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

.ti -2
.br
\fBFunction: \fR ustr_cspn_fwd()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string, containing spanning bytes
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cspn_buf_fwd() but passing ustr_cstr() and ustr_len()

.ti -2
.br
\fBFunction: \fR ustr_cspn_rev()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr string, containing spanning bytes
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cspn_buf_rev() but passing ustr_cstr() and ustr_len()

.ti -2
.br
\fBFunction: \fR ustr_cspn_cstr_fwd()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string, containing spanning bytes
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cspn_buf_fwd() but passing strlen() for the length.

.ti -2
.br
\fBFunction: \fR ustr_cspn_cstr_rev()
.br
Returns: Number of bytes not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style string, containing spanning bytes
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function works like ustr_cspn_buf_rev() but passing strlen() for the length.

.ti -2
.br
\fBFunction: \fR ustr_utf8_spn_chrs_fwd()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style UTF-8 string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of the C-style UTF-8 string
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function works like ustr_spn_chrs_fwd() but the return value, offset, and length all use UTF-8 characters and not bytes.
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_spn_chrs_rev()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style UTF-8 string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: 
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_spn_fwd()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_spn_rev()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_spn_cstr_fwd()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style UTF-8 string
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_spn_cstr_rev()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style UTF-8 string
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_cspn_chrs_fwd()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style UTF-8 string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of the C-style UTF-8 string
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_cspn_chrs_rev()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant C-style UTF-8 string
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of the C-style UTF-8 string
.br
Type\fB[4]\fR: size_t

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_cspn_fwd()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to a constant Ustr UTF-8 string, containing spanning data
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_cspn_rev()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to constant Ustr UTF-8 string data, containing spanning data
.br
Type\fB[3]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_cspn_cstr_fwd()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to constant C-style UTF-8 string data, containing spanning data
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

.ti -2
.br
\fBFunction: \fR ustr_utf8_cspn_cstr_rev()
.br
Returns: Number of UTF-8 characters not in the span
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr UTF-8 string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string, in UTF-8 characters, to start compliment spanning from
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: A pointer to C-style UTF-8 string data, containing spanning data
.br
Type\fB[3]\fR: const char *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!
.sp
\fBNote:\fR

.br
  This is much slower than ustr_spn_chrs_fwd() but given "xy" as a multi-byte UTF-8 character it understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

.SH Doing IO from or to a Ustr
.ti -2
.br
\fBFunction: \fR ustr_io_get()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: 
.br
Type\fB[2]\fR: FILE *

.br
Parameter\fB[3]\fR: 
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: 
.br
Type\fB[4]\fR: size_t *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_getfile()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  FILE *
.br
Type\fB[2]\fR:  FILE *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_getfilename()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  const char *
.br
Type\fB[2]\fR:  const char *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_getline()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  FILE *
.br
Type\fB[2]\fR:  FILE *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_put()
.br
Returns: int 
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  FILE *
.br
Type\fB[2]\fR:  FILE *

.br
Parameter\fB[3]\fR:  size_t
.br
Type\fB[3]\fR:  size_t

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_putline()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  FILE *
.br
Type\fB[2]\fR:  FILE *

.br
Parameter\fB[3]\fR:  size_t
.br
Type\fB[3]\fR:  size_t

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_putfile()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  FILE *
.br
Type\fB[2]\fR:  FILE *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_putfileline()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  FILE *
.br
Type\fB[2]\fR:  FILE *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.ti -2
.br
\fBFunction: \fR ustr_io_putfilename()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  const char *
.br
Type\fB[2]\fR:  const char *

.br
Parameter\fB[3]\fR:  const char *
.br
Type\fB[3]\fR:  const char *

.br
\fBExplanation:\fR

.br
  This function is NOT DOCUMENTED YET!

.SH String substitution/replacement
.ti -2
.br
\fBFunction: \fR ustr_sub_buf()
.br
Returns: success or failure 
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR:  Position where to start replacement
.br
Type\fB[2]\fR:  size_t

.br
Parameter\fB[3]\fR: Buffer containing replacement string 
.br
Type\fB[3]\fR:  const void*

.br
Parameter\fB[4]\fR:  Length of buffer
.br
Type\fB[4]\fR:  size_t

.br
\fBExplanation:\fR

.br
  This function will replace the characters in the Ustr starting at the specified position using data from the buffer. .sp
\fBNote:\fR
.br
  The Ustr will be automatically be resized if necessary.

.ti -2
.br
\fBFunction: \fR ustr_sub_cstr()
.br
Returns: success or failure 
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Position where to start replacement
.br
Type\fB[2]\fR:  size_t

.br
Parameter\fB[3]\fR:  Replacement Cstring
.br
Type\fB[3]\fR:  const char *

.br
\fBExplanation:\fR

.br
  This function will replace characters in the Ustr starting at the specified position using data from the given Cstring.

.ti -2
.br
\fBFunction: \fR ustr_sc_sub()
.br
Returns: success or failure 
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Position where to start replacement
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Length of replacement
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: Pointer to a Ustr containing the replacement string
.br
Type\fB[4]\fR: const struct Ustr *

.br
\fBExplanation:\fR

.br
  Replaces a specified number of characters starting at the given position with the characters from the given Ustr. 

.ti -2
.br
\fBFunction: \fR ustr_sc_sub_buf()
.br
Returns: success or failure 
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Position where to start replacement 
.br
Type\fB[2]\fR:  size_t 

.br
Parameter\fB[3]\fR:  Length of replacement
.br
Type\fB[3]\fR:  size_t 

.br
Parameter\fB[4]\fR:  Buffer containting replacement string
.br
Type\fB[4]\fR:  const void *

.br
Parameter\fB[5]\fR:  Length of Buffer
.br
Type\fB[5]\fR:  size_t 

.br
\fBExplanation:\fR

.br
  This function will replace a specific number of characters in a Ustr with the data from a buffer. 

.ti -2
.br
\fBFunction: \fR ustr_replace()
.br
Returns: Number of tokens replaced 
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr (haystack)
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Ustr to search for (needle)
.br
Type\fB[2]\fR: const struct Ustr *

.br
Parameter\fB[3]\fR: Ustr to replace needle with
.br
Type\fB[3]\fR: const struct Ustr *

.br
Parameter\fB[4]\fR:  Maximum number of matches to replace (0 for unlimited)
.br
Type\fB[4]\fR:  size_t

.br
\fBExplanation:\fR

.br
  This function scans the "haystack" (Parameter[1]) for "needle" (Parameter[2]) and replaces max_replacements (Parameter[4]) matches with the "replacement" (Parameter[3]).
Note: 
.br
  If max_replacements (Parameter[4]) is 0, this function will replace ALL occurrences.

.ti -2
.br
\fBFunction: \fR ustr_replace_rep_chr()
.br
Returns: number of replacements made
.br
Type: size_t

.br
Parameter\fB[1]\fR: pointer to a pointer to a Ustr to be modified
.br
Type\fB[1]\fR: struct Ustr **ps1

.br
Parameter\fB[2]\fR: character to replace
.br
Type\fB[2]\fR: char

.br
Parameter\fB[3]\fR: number of characters to replace
.br
Type\fB[3]\fR: size_t

.br
Parameter\fB[4]\fR: character to replace with
.br
Type\fB[4]\fR: char

.br
Parameter\fB[5]\fR: number of characters to replace with
.br
Type\fB[5]\fR: size_t nlen

.br
Parameter\fB[6]\fR: maximum number of replacements to make (use 0 for unlimited)
.br
Type\fB[6]\fR: size_t lim

.br
\fBExplanation:\fR
.br
  This function replaces a repeating sequence of characters with another
.br
  repeating sequence of characters. 

.br
  For example:
.br
  Ustr *data = ustr_dup_cstr("xxxBxxCxDxxx");
.br
  ustr_replace_rep_chr(&data,'x',2,'y',1, 0)
.br
  would change data to be "yxByCxDyx".
.sp
\fBNote:\fR
.br
  Changing the same letter the same number of times is considered a No-op
.br
  since it is a vast performance improvement this way. So passing in 
.br
  (&data,'y',2,'y',2 ,0) will have a return value of 0 and the string will be
.br
  unchanged.

.SH Splitting a Ustr
.ti -2
.br
\fBFunction: \fR ustr_split_buf()
.br
Returns: pointer to a Ustr representing the next token
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: pointer to a Ustr to be split
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: pointer to an offset variable
.br
Type\fB[2]\fR: size_t *

.br
Parameter\fB[3]\fR: buffer to use as split search pattern 
.br
Type\fB[3]\fR: const void *

.br
Parameter\fB[4]\fR: length of buffer
.br
Type\fB[4]\fR: size_t

.br
Parameter\fB[5]\fR: pointer to a Ustr where the return value will be placed
.br
Type\fB[5]\fR: struct Ustr *

.br
Parameter\fB[6]\fR: flags
.br
Type\fB[6]\fR: unsigned int

.br
\fBExplanation:\fR
.br
  This function works in a manner similar to strtok(). Each time the function is called, the string inside of the buffer (Parameter[3]) is used as a search pattern at which to split. If the pattern is not found, the entire string will be returned. A USTR_NULL return value indicates there are no more tokens remaining.

.br
  Parameter[5] is a a pointer to a Ustr where the return value will be placed. Passing a USTR_NULL to this parameter will cause the string to be allocated and **MUST BE FREED manually**. If, however, you pass in a non-null Ustr to this parameter, each call to ustr_split_buf() will free what is in this pointer and place the new token there (when USTR_NULL is returned, nothing needs to be free'd).
  For example...

.Vb 4
  Ustr *data = ...;
  Ustr *tok = USTR_NULL;
  const char *sep = "=";
  size_t off;
  flags = (USTR_FLAGS_SPLIT_RET_SEP|USTR_FLAGS_SPLIT_RET_NON);

  ...there are two options...

.Vb 4
  while ((tok = ustr_split_buf(data, &off, sep, strlen(sep), **tok**, flags))) {
    /* do something with tok -- but next iteration of the loop will free
       and overwrite tok, so you must ustr_dup() if you want to keep it */
  }
   /* tok is now NULL again after the loop */

   OR

  while ((tok = ustr_split_buf(data, &off, sep, strlen(sep), **USTR_NULL**, flags))) {
    /*do something with tok, and it will NOT be freed in the next iteration of
    the loop*/
      ustr_free(tok); /* have to free to avoid mem leaks */
  }
  
  Note:

  Explanation of flags --
    **USTR_FLAG_SPLIT_RET_SEP** -- return the separator along with the tokens. For
    example: splitting "a,b," using separator "," will return the tokens "a,"
    and "b," whereas without this option only "a" and "b" would be returned.
    
    **USTR_FLAG_SPLIT_RET_NON** -- return empty tokens. For example: splitting
    "a,,b" with separator "," will return the tokens {"a" "" "b"}.

    **USTR_FLAG_SPLIT_KEEP_CONFIG** -- force token Ustrs to have same
    configuration parameters as the original string.

    **USTR_FLAG_SPLIT_DEF** -- default flags, which is a shortcut for none of
    the above.


.ti -2
.br
\fBFunction: \fR ustr_split()
.br
Returns:  pointer to a Ustr representing the next token
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: pointer to a Ustr to be split
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: pointer to an offset variable
.br
Type\fB[2]\fR: size_t *

.br
Parameter\fB[3]\fR: pointer to a Ustr to use as the split search pattern
.br
Type\fB[3]\fR: const struct Ustr *

.br
Parameter\fB[4]\fR: pointer to a Ustr where the return value will be placed
.br
Type\fB[4]\fR: struct Ustr *

.br
Parameter\fB[5]\fR: flags
.br
Type\fB[5]\fR: unsigned int

.br
\fBExplanation:\fR   Works like ustr_split_buf() but takes a Ustr as the split search pattern
  instead.


.ti -2
.br
\fBFunction: \fR ustr_split_cstr()
.br
Returns:  pointer to a Ustr representing the next token
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: pointer to a Ustr to be split
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: pointer to an offset variable
.br
Type\fB[2]\fR: size_t *

.br
Parameter\fB[3]\fR: C string to use as split search pattern
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: pointer to a Ustr where the return value will be placed
.br
Type\fB[4]\fR: struct Ustr *

 Parameter[5]:
.br
Type\fB[5]\fR: unsigned int

.br
\fBExplanation:\fR  Works like ustr_split_buf() but takes a C string as the split search
  pattern.

.ti -2
.br
\fBFunction: \fR ustr_split_spn_chrs()
.br
Returns: Pointer to a Ustr representing the next token
.br
Type: struct Ustr *

.br
Parameter\fB[1]\fR: Pointer to a Ustr to be split
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Pointer to an offset variable
.br
Type\fB[2]\fR: size_t *

.br
Parameter\fB[3]\fR: String representing a set of bytes to use as split chars
.br
Type\fB[3]\fR: const char *

.br
Parameter\fB[4]\fR: Length of the string of set of bytes
.br
Type\fB[4]\fR: size_t

.br
Parameter\fB[5]\fR: Pointer to a Ustr where the return value will be placed
.br
Type\fB[5]\fR: struct Ustr *

.br
Parameter\fB[6]\fR: flags
.br
Type\fB[6]\fR: unsigned int

.br
\fBExplanation:\fR  Works like ustr_split_buf() but uses the individual characters in the
 separator string (Parameter[3]) as search patterns. It will split if ANY of
 these individual characters are matched (much like strtok()). For example:
 if splitting "thisXisYaZtest" with the separator string "XYZ" the tokens
 returned would be {"this" "is" "a" "test"};


.SH Dealing with UTF-8 in a Ustr
.ti -2
.br
\fBFunction: \fR ustr_utf8_valid()
.br
Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR
  This function tries it's best to find out if the string is a valid utf-8
 string.



.ti -2
.br
\fBFunction: \fR ustr_utf8_len()
.br
Returns: The number of the utf-8 characters in the Ustr
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR
  This function counts the number of utf-8 characters inn the Ustr.

.sp
\fBNote:\fR
  This function gives undefined answers on strings that aren't utf-8 valid.


.ti -2
.br
\fBFunction: \fR ustr_utf8_width()
.br
Returns: ssize_t 
.br
Type: ssize_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
\fBExplanation:\fR
  This function is NOT DOCUMENTED YET!


.ti -2
.br
\fBFunction: \fR ustr_utf8_chars2bytes()
.br
Returns: size_t 
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR:  size_t
.br
Type\fB[2]\fR:  size_t

.br
Parameter\fB[3]\fR:  size_t
.br
Type\fB[3]\fR:  size_t

.br
Parameter\fB[4]\fR:  size_t *
.br
Type\fB[4]\fR:  size_t *

.br
\fBExplanation:\fR
  This function is NOT DOCUMENTED YET!


.ti -2
.br
\fBFunction: \fR ustr_utf8_bytes2chars()
.br
Returns: size_t 
.br
Type: size_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR:  size_t
.br
Type\fB[2]\fR:  size_t

.br
Parameter\fB[3]\fR:  size_t
.br
Type\fB[3]\fR:  size_t

.br
Parameter\fB[4]\fR:  size_t *
.br
Type\fB[4]\fR:  size_t *

.br
\fBExplanation:\fR
  This function is NOT DOCUMENTED YET!


.SH Parsing ASCII integer numbers from a Ustr
.ti -2
.br
\fBFunction: \fR ustr_parse_uintmaxx()
.br
Returns: Parsed number, or zero on error
.br
Type: uintmax_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Absolute minimum value
.br
Type\fB[4]\fR: uintmax_t

.br
Parameter\fB[5]\fR: Absolute maximum value
.br
Type\fB[5]\fR: uintmax_t

.br
Parameter\fB[6]\fR: Thousands seperator
.br
Type\fB[6]\fR: const char *

.br
Parameter\fB[7]\fR: Return length of parsed number
.br
Type\fB[7]\fR: size_t *

.br
Parameter\fB[8]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[8]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function parses an ASCII representation of a number from a
 Ustr (Parameter[1]) starting at the offset (Parameter[2]).

.sp
\fBNote:\fR
  If stdint.h isn't available this function won't be available.


.ti -2
.br
\fBFunction: \fR ustr_parse_uintmax()
.br
Returns: Parsed number, or zero on error
.br
Type: uintmax_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_uintmaxx() with the minimum and maximum
 values taken as 0 and UINTMAX_MAX, and the thousands seperator as "_".

.sp
\fBNote:\fR
  If stdint.h isn't available this function won't be available.


.ti -2
.br
\fBFunction: \fR ustr_parse_intmax()
.br
Returns: Parsed number, or zero on error
.br
Type: intmax_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_uintmaxx() with the minimum and maximum
 values taken as -INTMAX_MIN and INTMAX_MAX, and the thousands seperator as "_".

.sp
\fBNote:\fR
  If stdint.h isn't available this function won't be available.


.ti -2
.br
\fBFunction: \fR ustr_parse_ulongx()
.br
Returns: Parsed number, or zero on error
.br
Type: unsigned long 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR:  size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR:  unsigned int

.br
Parameter\fB[4]\fR: Absolute minimum value
.br
Type\fB[4]\fR:  unsigned long

.br
Parameter\fB[5]\fR: Absolute maximum value
.br
Type\fB[5]\fR:  unsigned long

.br
Parameter\fB[6]\fR: Thousands seperator
.br
Type\fB[6]\fR: const char *

.br
Parameter\fB[7]\fR: Return length of parsed number
.br
Type\fB[7]\fR:  size_t *

.br
Parameter\fB[8]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[8]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_uintmaxx() but returns an unsigned long,
 it is always available even when stdint.h isn't.


.ti -2
.br
\fBFunction: \fR ustr_parse_ulong()
.br
Returns: Parsed number, or zero on error
.br
Type: unsigned long 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_ulongx() with the minimum and maximum
 values taken as 0 and ULONG_MAX, and the thousands seperator as "_".


.ti -2
.br
\fBFunction: \fR ustr_parse_long()
.br
Returns: Parsed number, or zero on error
.br
Type: long 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_ulongx() with the minimum and maximum
 values taken as -LONG_MIN and LONG_MAX, and the thousands seperator as "_".


.ti -2
.br
\fBFunction: \fR ustr_parse_uint()
.br
Returns: Parsed number, or zero on error
.br
Type: unsigned int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_ulongx() with the minimum and maximum
 values taken as 0 and UINT_MAX, and the thousands seperator as "_".


.ti -2
.br
\fBFunction: \fR ustr_parse_int()
.br
Returns: Parsed number, or zero on error
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_ulongx() with the minimum and maximum
 values taken as -INT_MIN and INT_MAX, and the thousands seperator as "_".


.ti -2
.br
\fBFunction: \fR ustr_parse_ushort()
.br
Returns: Parsed number, or zero on error
.br
Type: unsigned short 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_ulongx() with the minimum and maximum
 values taken as 0 and USHRT_MAX, and the thousands seperator as "_".


.ti -2
.br
\fBFunction: \fR ustr_parse_short()
.br
Returns: Parsed number, or zero on error
.br
Type: short 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
Parameter\fB[3]\fR: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
.br
Type\fB[3]\fR: unsigned int

.br
Parameter\fB[4]\fR: Return length of parsed number
.br
Type\fB[4]\fR: size_t *

.br
Parameter\fB[5]\fR: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
.br
Type\fB[5]\fR: unsigned int *

.br
\fBExplanation:\fR
  This function works like ustr_parse_ulongx() with the minimum and maximum
 values taken as -SHRT_MIN and SHRT_MAX, and the thousands seperator as "_".


.SH Misc shortcut helper functions for Ustrs
.ti -2
.br
\fBFunction: \fR ustr_sc_ensure_owner()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR
  This function makes sure that the Ustr string is owned when it returns (Ie.
 ustr_owner() returns USTR_TRUE), or it fails to allocate.


.ti -2
.br
\fBFunction: \fR ustr_sc_reverse()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR
  This function reverses all the bytes in a Ustr string, so the last one
 becomes the first and the second to last becomes the second etc.


.ti -2
.br
\fBFunction: \fR ustr_sc_tolower()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR
  This function changes any ASCII upper case bytes into ASCII lower case bytes.


.ti -2
.br
\fBFunction: \fR ustr_sc_toupper()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR
  This function changes any ASCII lower case bytes into ASCII upper case bytes.


.ti -2
.br
\fBFunction: \fR ustr_sc_wstr()
.br
Returns: Writable pointer to the start of data in the Ustr, or NULL
.br
Type: char *

.br
Parameter\fB[1]\fR: A pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
\fBExplanation:\fR
  This function works like calling ustr_sc_ensure_owner(), to make sure the
 Ustr string is writable, and if that succeeds it returns ustr_wstr(). On
 failure it returns NULL.


.SH Adding binary data to a Ustr
.ti -2
.br
\fBFunction: \fR ustr_add_b_uint16()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Binary value to add to the Ustr
.br
Type\fB[2]\fR: uint_least16_t

.br
\fBExplanation:\fR
  This function adds a binary representation of a value (Parameter[2]) to the
 Ustr (Parameter[1]).


.ti -2
.br
\fBFunction: \fR ustr_add_b_uint32()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Binary value to add to the Ustr
.br
Type\fB[2]\fR: uint_least32_t

.br
\fBExplanation:\fR
  This function adds a binary representation of a value (Parameter[2]) to the
 Ustr (Parameter[1]).


.ti -2
.br
\fBFunction: \fR ustr_add_b_uint64()
.br
Returns: Success or failure
.br
Type: int 

.br
Parameter\fB[1]\fR: Pointer to a pointer to a Ustr string
.br
Type\fB[1]\fR: struct Ustr **

.br
Parameter\fB[2]\fR: Binary value to add to the Ustr
.br
Type\fB[2]\fR: uint_least64_t

.br
\fBExplanation:\fR
  This function adds a binary representation of a value (Parameter[2]) to the
 Ustr (Parameter[1]).


.SH Parsing binary data from a Ustr
.ti -2
.br
\fBFunction: \fR ustr_parse_b_uint16()
.br
Returns: uint_least16_t 
.br
Type: uint_least16_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
\fBExplanation:\fR
  This function parses a binary representation from a Ustr (Parameter[1]) 
 starting at the offset (Parameter[2]).


.ti -2
.br
\fBFunction: \fR ustr_parse_b_uint32()
.br
Returns: uint_least32_t 
.br
Type: uint_least32_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
\fBExplanation:\fR
  This function parses a binary representation from a Ustr (Parameter[1]) 
 starting at the offset (Parameter[2]).


.ti -2
.br
\fBFunction: \fR ustr_parse_b_uint64()
.br
Returns: uint_least64_t 
.br
Type: uint_least64_t 

.br
Parameter\fB[1]\fR: A pointer to a constant Ustr string
.br
Type\fB[1]\fR: const struct Ustr *

.br
Parameter\fB[2]\fR: Offset within string to start parsing at
.br
Type\fB[2]\fR: size_t

.br
\fBExplanation:\fR
  This function parses a binary representation from a Ustr (Parameter[1]) 
 starting at the offset (Parameter[2]).


.SH Simple Ustr pool API
.ti -2
.br
\fBFunction: \fR ustr_pool_make_pool()
.br
Returns: Ustr pool object
.br
Type: struct Ustr_pool *

.br
Parameter\fB[1]\fR: Nothing
.br
Type\fB[1]\fR: void

.br
\fBExplanation:\fR
  This allocates a new pool.

.ti -2
.br
\fBFunction: \fR ustr_pool_make_subpool()
.br
Returns: struct Ustr_pool *
.br
Type: struct Ustr_pool *

.br
Parameter\fB[1]\fR: struct Ustr_pool *
.br
Type\fB[1]\fR: struct Ustr_pool *

.br
\fBExplanation:\fR
  This allocates a new pool as a child of the passed in pool (Parameter[1]),
 The pool can be freed and cleared independantly of the parent pool however
 free and clear operations on the parent pool are automatically applied to all
 child pools.


.ti -2
.br
\fBFunction: \fR ustr_pool_free()
.br
Returns: Nothing
.br
Type: void

.br
Parameter\fB[1]\fR: Ustr pool object
.br
Type\fB[1]\fR: struct Ustr_pool *

.br
\fBExplanation:\fR
  This deallocates a pool, and all sub-pools.

.sp
\fBNote:\fR
  This also operates on all sub-pools.


.ti -2
.br
\fBFunction: \fR ustr_pool_clear()
.br
Returns: Nothing
.br
Type: void

.br
Parameter\fB[1]\fR: Ustr pool object
.br
Type\fB[1]\fR: struct Ustr_pool *

.br
\fBExplanation:\fR
  This allows all the data in the pool to be reused, it may also free some/all
 of the data in the pool, from the pool API.

.sp
\fBNote:\fR
  This also operates on all sub-pools.

.SH "SEE ALSO"
.BR ustr_const (3)
