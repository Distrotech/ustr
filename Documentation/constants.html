<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Ustr - 1.0.4 reference documentation -- constants</title>
    <style type="text/css">
      A:visited { color: #ff4040; }
      A:hover { color: #20b2aa; }

      P { text-indent: 1em; }

      body     { background: #FFF; color: #000; }

      h2.ind   { background: #DDF; }

      td.title { background: #DFD; }
      td.sect  { background: #DDF; }
      td.obj   { background: #DDD; }

      ul li                       { list-style-type: lower-roman; }
      ul li:hover                 { list-style-type: square; }
      ul:hover li                 { list-style-type: decimal; }
      ul li:hover ul li.obj       { list-style-type: decimal; }
      ul li:hover ul li.obj:hover { list-style-type: square; }
    </style>

  </head>
  <body>
<table width="100%"><tr><td class="title"><h1>Ustr - 1.0.4 reference documentation -- constants (60)</h1>
</td></tr></table><table width="90%"><tr><td>
<h2 class="ind">Index of sections</h2>
<ul>
<li><a href="#indx-Compile_switch_constants">Compile switch constants (6)</a>
<li><a href="#indx-Constants_to_created_fixedreadonly_Ustrs">Constants to created fixed/read-only Ustr's (10)</a>
<li><a href="#indx-Constants_to_use_with_parsing_numbers:_ustr_parse_uintmaxx_etc">Constants to use with parsing numbers: ustr_parse_uintmaxx, etc. (16)</a>
<li><a href="#indx-Constants_to_pass_to_ustr_split">Constants to pass to ustr_split* (4)</a>
<li><a href="#indx-Misc_constants_to_use_in_code">Misc constants to use in code (4)</a>
<li><a href="#indx-Constants_passed_to_ustr_cntl_opt">Constants passed to ustr_cntl_opt() (16)</a>
<li><a href="#indx-Constants_passed_to_ustr_pool_ll_cntl">Constants passed to ustr_pool_ll_cntl() (4)</a></ul>
<h2 class="ind">Index of sections, and their contents</h2>
<ul>
<li><a id="indx-Compile_switch_constants" href="#Compile_switch_constants">Compile switch constants</a>
<ul>
<li class="obj"><a href="#USTR_CONF_INCLUDE_CODEONLY_HEADERS">USTR_CONF_INCLUDE_CODEONLY_HEADERS</a>
<li class="obj"><a href="#USTR_CONF_USE_EOS_MARK">USTR_CONF_USE_EOS_MARK</a>
<li class="obj"><a href="#USTR_CONF_USE_ASSERT">USTR_CONF_USE_ASSERT</a>
<li class="obj"><a href="#USTR_CONF_COMPILE_USE_ATTRIBUTES">USTR_CONF_COMPILE_USE_ATTRIBUTES</a>
<li class="obj"><a href="#USTR_CONF_COMPILE_TYPEDEF">USTR_CONF_COMPILE_TYPEDEF</a>
<li class="obj"><a href="#USTR_CONF_COMPILE_USE_INLINE">USTR_CONF_COMPILE_USE_INLINE</a>
</ul><li><a id="indx-Constants_to_created_fixedreadonly_Ustrs" href="#Constants_to_created_fixedreadonly_Ustrs">Constants to created fixed/read-only Ustr's</a>
<ul>
<li class="obj"><a href="#USTR_BEG_CONST1">USTR_BEG_CONST1</a>
<li class="obj"><a href="#USTR_BEG_CONST2">USTR_BEG_CONST2</a>
<li class="obj"><a href="#USTR_BEG_CONST4">USTR_BEG_CONST4</a>
<li class="obj"><a href="#USTR_BEG_FIXED1">USTR_BEG_FIXED1</a>
<li class="obj"><a href="#USTR_BEG_FIXED2">USTR_BEG_FIXED2</a>
<li class="obj"><a href="#USTR_BEG_FIXED4">USTR_BEG_FIXED4</a>
<li class="obj"><a href="#USTR_BEG_FIXED8">USTR_BEG_FIXED8</a>
<li class="obj"><a href="#USTR_END_ALOCDx">USTR_END_ALOCDx</a>
<li class="obj"><a href="#USTR_END_CONSTx">USTR_END_CONSTx</a>
<li class="obj"><a href="#USTR_END_FIXEDx">USTR_END_FIXEDx</a>
</ul><li><a id="indx-Constants_to_use_with_parsing_numbers:_ustr_parse_uintmaxx_etc" href="#Constants_to_use_with_parsing_numbers:_ustr_parse_uintmaxx_etc">Constants to use with parsing numbers: ustr_parse_uintmaxx, etc.</a>
<ul>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_DEF">USTR_FLAG_PARSE_NUM_DEF</a>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_SEP">USTR_FLAG_PARSE_NUM_SEP</a>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_OVERFLOW">USTR_FLAG_PARSE_NUM_OVERFLOW</a>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_SPACE">USTR_FLAG_PARSE_NUM_SPACE</a>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_NO_BEG_ZERO">USTR_FLAG_PARSE_NUM_NO_BEG_ZERO</a>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_NO_BEG_PM">USTR_FLAG_PARSE_NUM_NO_BEG_PM</a>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_NO_NEGATIVE">USTR_FLAG_PARSE_NUM_NO_NEGATIVE</a>
<li class="obj"><a href="#USTR_FLAG_PARSE_NUM_EXACT">USTR_FLAG_PARSE_NUM_EXACT</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_NONE">USTR_TYPE_PARSE_NUM_ERR_NONE</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_ONLY_S">USTR_TYPE_PARSE_NUM_ERR_ONLY_S</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_ONLY_SPM">USTR_TYPE_PARSE_NUM_ERR_ONLY_SPM</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX">USTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_OOB">USTR_TYPE_PARSE_NUM_ERR_OOB</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_OVERFLOW">USTR_TYPE_PARSE_NUM_ERR_OVERFLOW</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_NEGATIVE">USTR_TYPE_PARSE_NUM_ERR_NEGATIVE</a>
<li class="obj"><a href="#USTR_TYPE_PARSE_NUM_ERR_BEG_ZERO">USTR_TYPE_PARSE_NUM_ERR_BEG_ZERO</a>
</ul><li><a id="indx-Constants_to_pass_to_ustr_split" href="#Constants_to_pass_to_ustr_split">Constants to pass to ustr_split*</a>
<ul>
<li class="obj"><a href="#USTR_FLAG_SPLIT_DEF">USTR_FLAG_SPLIT_DEF</a>
<li class="obj"><a href="#USTR_FLAG_SPLIT_RET_SEP">USTR_FLAG_SPLIT_RET_SEP</a>
<li class="obj"><a href="#USTR_FLAG_SPLIT_RET_NON">USTR_FLAG_SPLIT_RET_NON</a>
<li class="obj"><a href="#USTR_FLAG_SPLIT_KEEP_CONFIG">USTR_FLAG_SPLIT_KEEP_CONFIG</a>
</ul><li><a id="indx-Misc_constants_to_use_in_code" href="#Misc_constants_to_use_in_code">Misc constants to use in code</a>
<ul>
<li class="obj"><a href="#USTR_NULL">USTR_NULL</a>
<li class="obj"><a href="#USTR_POOL_NULL">USTR_POOL_NULL</a>
<li class="obj"><a href="#USTR_TRUE">USTR_TRUE</a>
<li class="obj"><a href="#USTR_FALSE">USTR_FALSE</a>
</ul><li><a id="indx-Constants_passed_to_ustr_cntl_opt" href="#Constants_passed_to_ustr_cntl_opt">Constants passed to ustr_cntl_opt()</a>
<ul>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_REF_BYTES">USTR_CNTL_OPT_GET_REF_BYTES</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_REF_BYTES">USTR_CNTL_OPT_SET_REF_BYTES</a>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_HAS_SIZE">USTR_CNTL_OPT_GET_HAS_SIZE</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_HAS_SIZE">USTR_CNTL_OPT_SET_HAS_SIZE</a>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_EXACT_BYTES">USTR_CNTL_OPT_GET_EXACT_BYTES</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_EXACT_BYTES">USTR_CNTL_OPT_SET_EXACT_BYTES</a>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_MEM">USTR_CNTL_OPT_GET_MEM</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_MEM">USTR_CNTL_OPT_SET_MEM</a>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_MC_M_SCRUB">USTR_CNTL_OPT_GET_MC_M_SCRUB</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_MC_M_SCRUB">USTR_CNTL_OPT_SET_MC_M_SCRUB</a>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_MC_F_SCRUB">USTR_CNTL_OPT_GET_MC_F_SCRUB</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_MC_F_SCRUB">USTR_CNTL_OPT_SET_MC_F_SCRUB</a>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_MC_R_SCRUB">USTR_CNTL_OPT_GET_MC_R_SCRUB</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_MC_R_SCRUB">USTR_CNTL_OPT_SET_MC_R_SCRUB</a>
<li class="obj"><a href="#USTR_CNTL_OPT_GET_FMT">USTR_CNTL_OPT_GET_FMT</a>
<li class="obj"><a href="#USTR_CNTL_OPT_SET_FMT">USTR_CNTL_OPT_SET_FMT</a>
</ul><li><a id="indx-Constants_passed_to_ustr_pool_ll_cntl" href="#Constants_passed_to_ustr_pool_ll_cntl">Constants passed to ustr_pool_ll_cntl()</a>
<ul>
<li class="obj"><a href="#USTR_POOL_LL_CNTL_GET_FREE_CMP">USTR_POOL_LL_CNTL_GET_FREE_CMP</a>
<li class="obj"><a href="#USTR_POOL_LL_CNTL_SET_FREE_CMP">USTR_POOL_LL_CNTL_SET_FREE_CMP</a>
<li class="obj"><a href="#USTR_POOL_LL_CNTL_GET_REALLOC">USTR_POOL_LL_CNTL_GET_REALLOC</a>
<li class="obj"><a href="#USTR_POOL_LL_CNTL_SET_REALLOC">USTR_POOL_LL_CNTL_SET_REALLOC</a>
</ul></ul>
</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Compile%20switch%20constants">Compile switch constants</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CONF_INCLUDE_CODEONLY_HEADERS">USTR_CONF_INCLUDE_CODEONLY_HEADERS</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether all the code will be included as inline
 functions. Having this be non-zero means that you don't have to link against
 the library.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CONF_USE_EOS_MARK">USTR_CONF_USE_EOS_MARK</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch turns on End of String markers, so any bounds overflow will be
 noticed by <a href="functions#ustr_assert_valid">ustr_assert_valid()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Changing this will not do anything useful unless
 <a href="constants#USTR_CONF_INCLUDE_CODEONLY_HEADERS">USTR_CONF_INCLUDE_CODEONLY_HEADERS</a> is non-zero.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CONF_USE_ASSERT">USTR_CONF_USE_ASSERT</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch turns <a href="functions#USTR_ASSERT">USTR_ASSERT()</a> calls on, so the code within them will be
 evaluated. Note that there are many calls to <a href="functions#ustr_assert_valid">ustr_assert_valid()</a> within
 <a href="functions#USTR_ASSERT">USTR_ASSERT()</a> macros and that call is relatively expensive.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Changing this will not do anything useful unless
 <a href="constants#USTR_CONF_INCLUDE_CODEONLY_HEADERS">USTR_CONF_INCLUDE_CODEONLY_HEADERS</a> is non-zero.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CONF_COMPILE_USE_ATTRIBUTES">USTR_CONF_COMPILE_USE_ATTRIBUTES</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether gcc type __attribute__() statements are used in
 the public headers headers for the library. If the value is 1 then if they are
 supported by the compiler that built the library they will be used, if the
 value is 0 they won't be used at all.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CONF_COMPILE_TYPEDEF">USTR_CONF_COMPILE_TYPEDEF</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether typedef will be used for the structs in the
 public headers for the library. If the value is 1 then they will be used,
 if the value is 0 they won't be used at all (and your code will have to use
 struct tags instead -- note all libraries using ustr should compile without
 this option set).

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CONF_COMPILE_USE_INLINE">USTR_CONF_COMPILE_USE_INLINE</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This switch controls whether inline functions will be used in a few cases
 where the function bodies are very small.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  In some cases this is used so that GCC can eliminate calls to strlen(), for
 the *_cstr() functions.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Constants%20to%20created%20fixed%2fread%2donly%20Ustr%27s">Constants to created fixed/read-only Ustr's</a></h2>
</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_BEG_CONST1">USTR_BEG_CONST1</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the first byte of a
 constant/read-only Ustr that has a length in the range 0-255.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_BEG_CONST2">USTR_BEG_CONST2</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the first byte of a
 constant/read-only Ustr that has a length in the range 0-65535.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_BEG_CONST4">USTR_BEG_CONST4</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the first byte of a
 constant/read-only Ustr that has a length in the range 0-4294967295.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_BEG_FIXED1">USTR_BEG_FIXED1</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-255.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_BEG_FIXED2">USTR_BEG_FIXED2</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-65535.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_BEG_FIXED4">USTR_BEG_FIXED4</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-4294967295.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_BEG_FIXED8">USTR_BEG_FIXED8</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the first byte of a
 fixed Ustr that has a length in the range 0-18446744073709551615.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This macro is only available if the Ustr code was compiled in a 64bit
 environment.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_END_ALOCDx">USTR_END_ALOCDx</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the last bytes of an
 allocated Ustr.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Unless <a href="constants#USTR_CONF_USE_EOS_MARK">USTR_CONF_USE_EOS_MARK</a> is non-zero, this is just the NIL byte.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_END_CONSTx">USTR_END_CONSTx</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the last bytes of a
 constant/read-only Ustr.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Unless <a href="constants#USTR_CONF_USE_EOS_MARK">USTR_CONF_USE_EOS_MARK</a> is non-zero, this is just the NIL byte.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_END_FIXEDx">USTR_END_FIXEDx</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is a constant C-style string of the last bytes of a
 fixed Ustr.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Unless <a href="constants#USTR_CONF_USE_EOS_MARK">USTR_CONF_USE_EOS_MARK</a> is non-zero, this is just the NIL byte.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Constants%20to%20use%20with%20parsing%20numbers:%20ustr_parse_uintmaxx%2c%20etc%2e">Constants to use with parsing numbers: ustr_parse_uintmaxx, etc.</a></h2>
</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_DEF">USTR_FLAG_PARSE_NUM_DEF</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Default flags, this is merely 0 but can be used as live documentation.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_SEP">USTR_FLAG_PARSE_NUM_SEP</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows the parsing (and ignoring) of the seperator character, at
 arbitrary pointers in the number, so "1234" and "1_234" would both parse the
 same (assuming "_" is the seperator).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_OVERFLOW">USTR_FLAG_PARSE_NUM_OVERFLOW</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag turns on the overflow checking, in other words without it
 <a href="constants#USTR_TYPE_PARSE_NUM_ERR_OVERFLOW">USTR_TYPE_PARSE_NUM_ERR_OVERFLOW</a> will never be returned as an error
 code.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_SPACE">USTR_FLAG_PARSE_NUM_SPACE</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag allows one or more ' ' (Space) characters before the number
 or number prefix (Plus Sign, Hyphen).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Other forms of whitespace don't count, this just affects ' '.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_NO_BEG_ZERO">USTR_FLAG_PARSE_NUM_NO_BEG_ZERO</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag disallows one or more '0' (Digit Zero) characters before
 the number.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_NO_BEG_PM">USTR_FLAG_PARSE_NUM_NO_BEG_PM</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag disallows a plus or a minus character before the number.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_NO_NEGATIVE">USTR_FLAG_PARSE_NUM_NO_NEGATIVE</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag disallows negative values.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_PARSE_NUM_EXACT">USTR_FLAG_PARSE_NUM_EXACT</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This flag makes the parsing functions return an error if the entire string
 doesn't contain the number being parsed.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_NONE">USTR_TYPE_PARSE_NUM_ERR_NONE</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code has the value 0, and means that no error occurred
 parsing the number.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_ONLY_S">USTR_TYPE_PARSE_NUM_ERR_ONLY_S</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the <a href="design">Ustr string</a> consisted only of spaces.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_ONLY_SPM">USTR_TYPE_PARSE_NUM_ERR_ONLY_SPM</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the <a href="design">Ustr string</a> consisted only spaces, and
 a plus or minus sign.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX">USTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the <a href="design">Ustr string</a> consisted of only spaces, a
 plus or minus sign and a "0x" base 16 prefix.

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_OOB">USTR_TYPE_PARSE_NUM_ERR_OOB</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the <a href="design">Ustr string</a> had characters in it that
 where out of bounds from the working base.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Without the <a href="constants#USTR_FLAG_PARSE_NUM_EXACT">USTR_FLAG_PARSE_NUM_EXACT</a>, this error is ignored as soon as any
 number is parsed.
</p><p>  This out of bounds includes the <a href="design">Ustr string</a> &quot;++&quot; as well as &quot;4A&quot;,
 when parsing in a base less than 11.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_OVERFLOW">USTR_TYPE_PARSE_NUM_ERR_OVERFLOW</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the number parsed from the <a href="design">Ustr string</a>
 would overflow the type it is being parsed into, this is only returned
 when the <a href="constants#USTR_FLAG_PARSE_NUM_OVERFLOW">USTR_FLAG_PARSE_NUM_OVERFLOW</a> flag was passed to the parse
 function.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_NEGATIVE">USTR_TYPE_PARSE_NUM_ERR_NEGATIVE</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the number parsed from the Vstr string
 starts with a '-' (Hyphen) character when it is supposed to be an
 unsigned number.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TYPE_PARSE_NUM_ERR_BEG_ZERO">USTR_TYPE_PARSE_NUM_ERR_BEG_ZERO</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This error code means that the number parsed from the Vstr string
 starts with a '0' (Digit Zero) character, when the
 <a href="constants#USTR_FLAG_PARSE_NUM_NO_BEG_ZERO">USTR_FLAG_PARSE_NUM_NO_BEG_ZERO</a> flag was passed to the parse function.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Constants%20to%20pass%20to%20ustr_split%2a">Constants to pass to ustr_split*</a></h2>
</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_SPLIT_DEF">USTR_FLAG_SPLIT_DEF</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Default flags, this is merely 0 but can be used as live documentation.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_SPLIT_RET_SEP">USTR_FLAG_SPLIT_RET_SEP</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Return the separator along with the tokens. For example splitting &quot;a,b,&quot;
 using separator "," will return the tokens "a," and "b," whereas without this
 flag only "a" and "b" would be returned.
</p><p>    
</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_SPLIT_RET_NON">USTR_FLAG_SPLIT_RET_NON</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Return empty tokens. For example: splitting &quot;a,,b&quot; with separator &quot;,&quot; will
 return the tokens {"a" "" "b"}.

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FLAG_SPLIT_KEEP_CONFIG">USTR_FLAG_SPLIT_KEEP_CONFIG</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Force the returned Ustr's to have same configuration parameters as the
 <a href="design">Ustr string</a> that is being split.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Misc%20constants%20to%20use%20in%20code">Misc constants to use in code</a></h2>
</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_NULL">USTR_NULL</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is merely 0 cast to (struct Ustr *), and can be used anywhere NULL
 would be but "returns" the correct type.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_POOL_NULL">USTR_POOL_NULL</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is merely 0 cast to (struct Ustr_pool *), and can be used anywhere
 NULL would be but "returns" the correct type.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_TRUE">USTR_TRUE</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is 1, but shows the intent that a boolean value is expected and not
 a number.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_FALSE">USTR_FALSE</a>

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro is 0, but shows the intent that a boolean value is expected and not
 a number.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Constants%20passed%20to%20ustr_cntl_opt%28%29">Constants passed to
			 	<a id="ustr_cntl_opt()"><a href="functions#ustr_cntl_opt">ustr_cntl_opt()</a></a>

		      </a></h2>
</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_REF_BYTES">USTR_CNTL_OPT_GET_REF_BYTES</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Number of bytes for default reference count in Ustr<br>Type<strong>[1]</strong>: size_t *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the default number of bytes used for a reference count
 when creating Ustr's.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_REF_BYTES">USTR_CNTL_OPT_SET_REF_BYTES</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Number of bytes for default reference count in Ustr<br>Type<strong>[1]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the default number of bytes used for a reference count
 when creating Ustr's.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  For a single instance, the ustr_dupx_*() functions can be used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_HAS_SIZE">USTR_CNTL_OPT_GET_HAS_SIZE</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Default flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the default flag for whether to store an explicit size
 in created Ustr's.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_HAS_SIZE">USTR_CNTL_OPT_SET_HAS_SIZE</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Default flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the default flag for whether to store an explicit size
 in created Ustr's.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  For a single instance, the ustr_dupx_*() functions can be used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_EXACT_BYTES">USTR_CNTL_OPT_GET_EXACT_BYTES</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Default flag for whether to exactly allocate memory<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the default flag for whether to exactly allocate memory
 when a Ustr needs to be resized.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_EXACT_BYTES">USTR_CNTL_OPT_SET_EXACT_BYTES</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Default flag for whether to exactly allocate memory<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the default flag for whether to exactly allocate memory
 when a Ustr needs to be resized.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  For a single instance, the ustr_dupx_*() functions can be used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_MEM">USTR_CNTL_OPT_GET_MEM</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to colleciton of function pointers for system allocation<br>Type<strong>[1]</strong>: struct Ustr_cntl_mem *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the &quot;system&quot; allocation functions (malloc, realloc, free)
 for allocated Ustr's.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  As you would expect the default values are: malloc, realloc, free.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_MEM">USTR_CNTL_OPT_SET_MEM</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to colleciton of function pointers for system allocation<br>Type<strong>[1]</strong>: const struct Ustr_cntl_mem *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the &quot;system&quot; allocation functions (malloc, realloc, free)
 for allocated Ustr's.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If this option is set after a Ustr has been created, then when freeing or
 reallocating the existing Ustr the given functions will be used. So they must
 either be compatible with the default or you must ensure that nothing is
 allocated before they are set.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_MC_M_SCRUB">USTR_CNTL_OPT_GET_MC_M_SCRUB</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the flag for whether to &quot;scrub&quot; data allocated via.
 malloc check.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Malloc check has to be enabled for this to mean anything, Ie.
 <a href="functions#USTR_CNTL_MALLOC_LVL">USTR_CNTL_MALLOC_LVL()</a> must be positive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_MC_M_SCRUB">USTR_CNTL_OPT_SET_MC_M_SCRUB</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the flag for whether to &quot;scrub&quot; data allocated via.
 malloc check.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Malloc check has to be enabled for this to mean anything, Ie.
 <a href="functions#USTR_CNTL_MALLOC_LVL">USTR_CNTL_MALLOC_LVL()</a> must be positive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_MC_F_SCRUB">USTR_CNTL_OPT_GET_MC_F_SCRUB</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the flag for whether to &quot;scrub&quot; data freed via.
 malloc check.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Malloc check has to be enabled for this to mean anything, Ie.
 <a href="functions#USTR_CNTL_MALLOC_LVL">USTR_CNTL_MALLOC_LVL()</a> must be positive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_MC_F_SCRUB">USTR_CNTL_OPT_SET_MC_F_SCRUB</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the flag for whether to &quot;scrub&quot; data freed via.
 malloc check.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Malloc check has to be enabled for this to mean anything, Ie.
 <a href="functions#USTR_CNTL_MALLOC_LVL">USTR_CNTL_MALLOC_LVL()</a> must be positive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_MC_R_SCRUB">USTR_CNTL_OPT_GET_MC_R_SCRUB</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the flag for whether to &quot;scrub&quot; data reallocated via.
 malloc check. This is done by turning all reallocations into a malloc() and
 free(), and so is even more costly than normal scrubbing.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Malloc check has to be enabled for this to mean anything, Ie.
 <a href="functions#USTR_CNTL_MALLOC_LVL">USTR_CNTL_MALLOC_LVL()</a> must be positive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_MC_R_SCRUB">USTR_CNTL_OPT_SET_MC_R_SCRUB</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for whether to include an explicit size in a Ustr<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the flag for whether to &quot;scrub&quot; data reallocated via.
 malloc check. This is done by turning all reallocations into a malloc() and
 free(), and so is even more costly than normal scrubbing.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Malloc check has to be enabled for this to mean anything, Ie.
 <a href="functions#USTR_CNTL_MALLOC_LVL">USTR_CNTL_MALLOC_LVL()</a> must be positive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_GET_FMT">USTR_CNTL_OPT_GET_FMT</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to colleciton of function pointers for system formating<br>Type<strong>[1]</strong>: struct Ustr_cntl_fmt *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the system formatting functions (vsnprintf) for Ustr's.
</p><p>  There are two functions, the first is always called and the second is likely
 called (always with the exact same arguments) if the length passed to the
 first call was not big enough.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  As you would expect the default values are: vsnprintf and vsnprintf


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_CNTL_OPT_SET_FMT">USTR_CNTL_OPT_SET_FMT</a>
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to colleciton of function pointers for system formatting<br>Type<strong>[1]</strong>: const struct Ustr_cntl_fmt *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the system formatting functions (vsnprintf) for Ustr's.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Constants%20passed%20to%20ustr_pool_ll_cntl%28%29">Constants passed to
			 	<a id="ustr_pool_ll_cntl()"><a href="functions#ustr_pool_ll_cntl">ustr_pool_ll_cntl()</a></a>

		      </a></h2>
</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_POOL_LL_CNTL_GET_FREE_CMP">USTR_POOL_LL_CNTL_GET_FREE_CMP</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Number of pointers to compare to in the pool<br>Type<strong>[1]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the number of comparisons done on a pool free operation.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_POOL_LL_CNTL_SET_FREE_CMP">USTR_POOL_LL_CNTL_SET_FREE_CMP</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Number of pointers to compare to in the pool<br>Type<strong>[1]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the number of comparisons done on a pool free operation.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The default is a small non-zero value, as it's significantly common to have
 very short lived ustr's ... however this doesn't mean that you can't forget to
 take references even with pool allocated ustrs.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_POOL_LL_CNTL_GET_REALLOC">USTR_POOL_LL_CNTL_GET_REALLOC</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for if we should call realloc()<br>Type<strong>[1]</strong>: int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will get the flag for if we call realloc() to make data bigger,
 or revert to just allocating anew each time.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Constant: </strong> <a id="USTR_POOL_LL_CNTL_SET_REALLOC">USTR_POOL_LL_CNTL_SET_REALLOC</a>

</td></tr><tr><td>Parameter<strong>[1]</strong>: Flag for if we should call realloc()<br>Type<strong>[1]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This option will set the flag for if we call realloc() to make data bigger,
 or revert to just allocating anew each time.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  As with <a href="constants#USTR_POOL_LL_CNTL_SET_FREE_CMP">USTR_POOL_LL_CNTL_SET_FREE_CMP</a> this option means you can't assume that
 pool allocated data is never freed until <a href="functions#ustr_pool_free">ustr_pool_free()</a> is called, and again
 it is due to there being significant speed improvements for not making that
 assumption. Instead of disabling this option, just take areference (which will
 also make sure the ustr isn't modified behind your back).


</td></tr></table>
</body></html>